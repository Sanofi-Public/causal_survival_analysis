{"title":"Causal survival analysis","markdown":{"yaml":{"title":"Causal survival analysis","subtitle":"Treatment Effect Estimation in Causal Survival Analysis: Practical Recommendations","author":[{"name":"Charlotte Voinot","corresponding":true,"email":"charlotte.voinot@sanofi.com","url":"https://chvoinot.github.io/","affiliations":[{"name":"Sanofi R&D","department":"CMEI","url":"https://www.sanofi.fr/fr/"},{"name":"INRIA","department":"Premedical","url":"https://www.inria.fr/fr/premedical"},{"name":"INSERM","url":"https://www.inserm.fr/"},{"name":"Université de Montpellier","url":"https://www.umontpellier.fr/"}]},{"name":"Clément Berenfeld","corresponding":true,"email":"clement.berenfeld@uni-potsdam.de","url":"https://cberenfeld.github.io","affiliations":[{"name":"Universität Potsdam, Potsdam, Germany","departement":"Institut für Mathematik","url":"https://www.uni-potsdam.de/en/university-of-potsdam"}]},{"name":"Imke Mayer","corresponding":true,"email":"imke.mayer@owkin.com, now affiliated with Owkin","affiliations":[{"name":"Charité -- Universität Berlin, Berlin, Germany","departement":"Institut für Public Health","url":"https://www.charite.de/"}]},{"name":"Bernard Sebastien","corresponding":true,"email":"bernard.sebastien@sanofi.com","affiliations":[{"name":"Sanofi R&D","department":"CMEI","url":"https://www.sanofi.fr/fr/"}]},{"name":"Julie Josse","corresponding":true,"email":"julie.josse@inria.fr","url":"https://juliejosse.com/","affiliations":[{"name":"INRIA","department":"Premedical","url":"https://www.inria.fr/fr/premedical"},{"name":"INSERM","url":"https://www.inserm.fr/"},{"name":"Université de Montpellier","url":"https://www.umontpellier.fr/"}]}],"date":"last-modified","date-modified":"last-modified","github-user":"chvoinot","repo":"Simple_simulation_causal_survival","format":{"html":{"self-contained":true},"pdf":"default"},"project":false,"editor":{"markdown":{"wrap":7}}},"headingText":"Estimators","containsRefs":false,"markdown":"\n\n\n\n\n**Unadjusted Kaplan-Meier** \n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nsource(\"utilitary.R\")\n# Kaplan-Meier estimator handmade implementation\n# The database 'data' must be in the same form as that shown in \n# notation (Table 1) and with the same variable names (status, T_obs) \nKaplan_meier_handmade <- function(data, \n                                  status = data$status, \n                                  T_obs = data$T_obs) {\n  # Sort unique observed times\n  Y.grid <- sort(unique(T_obs))\n  \n  # Initialize vectors for number of events, number at risk, and survival \n  # probability\n  d <- rep(NA, length(Y.grid))  # Number of events at time Y.grid[i]\n  n <- rep(NA, length(Y.grid))  # Number at risk just before time Y.grid[i]\n  S <- rep(NA, length(Y.grid))  # Survival probability at time Y.grid[i]\n  \n  # Loop over each unique observed time\n  for (i in 1:length(Y.grid)) {\n    d[i] <- sum(T_obs == Y.grid[i] & status == 1, na.rm = TRUE)  # Count events\n    n[i] <- sum(T_obs >= Y.grid[i])  # Count at risk\n    \n    # Calculate survival probability\n    S[i] <- cumprod(1 - d / n)[i]\n  }\n  \n  # Create a dataframe with the results\n  df <- data.frame(d = d, n = n, S = S, T = Y.grid)\n  \n  return(df)\n}\n\n\n# Function to calculate RMST (Restricted Mean Survival Time):\n# Two possibilities for computing RMST: \n# - in using directly S_A1 and S_A0 (survival function of treated and control)\n# - in using the dataframe and the function computes the survival functions\nRMST_1 <- function(data = NULL, A1 = 1, A0 = 0, tau, S_A1 = NULL, S_A0 = NULL) {\n  if (is.null(S_A1) & is.null(S_A0)) {\n    # Subset data for treatment groups\n    data1 <- data[data$A == A1,]\n    data0 <- data[data$A == A0,]\n    \n    # Calculate Kaplan-Meier survival estimates\n    S_A1 <- Kaplan_meier_handmade(data1, status = data1$status, \n                                  T_obs = data1$T_obs)\n    S_A0 <- Kaplan_meier_handmade(data0, status = data0$status, \n                                  T_obs = data0$T_obs)\n    \n    # Restrict observations to those less than or equal to tau\n    Y.grid1 <- data1$T_obs[data1$T_obs <= tau]\n    Y.grid0 <- data0$T_obs[data0$T_obs <= tau]\n  } else {\n    # Restrict observations to those less than or equal to tau\n    Y.grid1 <- S_A1$T[S_A1$T <= tau]\n    Y.grid0 <- S_A0$T[S_A0$T <= tau]\n  }\n  \n  # Filter survival estimates to restricted observations\n  S_A1 <- S_A1 %>%\n    dplyr::filter(T %in% Y.grid1)\n  S_A0 <- S_A0 %>%\n    dplyr::filter(T %in% Y.grid0)\n  \n  # Check if there is any event at tau for S_A1\n  if (!any(S_A1$T == tau)) {\n    new_row <- tibble(T = tau, S = S_A1$S[nrow(S_A1)])\n    S_A1 <- dplyr::bind_rows(S_A1, new_row)\n  }\n  \n  # Check if there is any event at tau for S_A0\n  if (!any(S_A0$T == tau)) {\n    new_row <- tibble(T = tau, S = S_A0$S[nrow(S_A0)])\n    S_A0 <- dplyr::bind_rows(S_A0, new_row)\n  }\n\n  # Calculate integrals from 0 to tau of survival probabilities\n  intA1 <- integral_rectangles(S_A1$T, S_A1$S)\n  intA0 <- integral_rectangles(S_A0$T, S_A0$S)\n  RMST1 <- intA1 - intA0\n  \n  return(list(RMST=RMST1, intA1=intA1,intA0=intA0))\n}\n\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Alternative code to estimate Kaplan-Meier estimator with survival package\n# instead of handmade KM\nRMST_alternative <- function(data, A1 = 1, A0 = 0, tau){\n  # Estimate Kaplan-Meier estimator with survfit function on data subset\n   # Groupe A = 0\n  fit0 <- survfit(Surv(T_obs, status) ~ 1, data = data[data$A == A0,]) \n  # Groupe A = 1\n  fit1 <- survfit(Surv(T_obs, status) ~ 1, data = data[data$A == A1,])  \n\n  # Estimate the RMST with rmean\n  summary_fit0 <- summary(fit0, rmean = tau)  # RMST for A = 0\n  summary_fit1 <- summary(fit1, rmean = tau)  # RMST for A = 1\n\n  # Extract the RMST from the summary objects\n  rmst0 <- summary_fit0$table[\"rmean\"][[1]]\n  rmst1 <- summary_fit1$table[\"rmean\"][[1]]\n\n  # Compute the difference of RMST between the two groups\n  difference_rmst <- rmst1 - rmst0\nreturn(difference_rmst)\n}\n```\n\n\n**IPCW Kaplan-Meier**\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Kaplan-Meier adjusted\n# Times of event \n# Failures:  1 if event, 0 if censored\n# Variable:  1 if treated, 0 if control\n# Weights:  Weight of the individual\nadjusted.KM <- function(times, failures, variable, weights = NULL) {\n  # Sanity checks\n  if (sum(times < 0) > 0) {\n    stop(\"Error: times must be positive\")\n  }\n  if (!is.null(weights) && sum(weights < 0, na.rm = TRUE) > 0) {\n    stop(\"Error: weights must be superior to 0\")\n  }\n  if (sum(failures != 0 & failures != 1) > 0) {\n    stop(\"Error: failures must be a vector of 0 or 1\")\n  }\n  # If 'weights' is NULL, initialize 'w' with ones of the same length as 'times', \n  # otherwise use 'weights'\n  w <- if (is.null(weights)) rep(1, length(times)) else weights\n  \n  # Create a DataFrame 'data' with columns t (times), f (failures), \n  # v (stratification variable: often treatment variable), and w (weights)\n  data <- data.frame(t = times, f = failures, v = variable, w = w)\n  \n  # Remove rows from the DataFrame where the stratification variable is NA\n  data <- data[!is.na(data$v),]\n  \n  # Initialize an empty DataFrame to store the Kaplan-Meier results\n  table_KM <- data.frame(times = NULL, n.risk = NULL, n.event = NULL, \n                         survival = NULL, variable = NULL)\n  \n  # Loop over each unique value of the stratification variable\n  for (i in unique(variable)) {\n    # Subset the data for the current stratification variable value\n    d <- data[data$v == i,]\n    \n    # Create a sorted vector of unique event times, including time 0 and the \n    # maximum time\n    tj <- c(0, sort(unique(d$t[d$f == 1])), max(d$t))\n    \n    # Calculate the number of events at each time point\n    dj <- sapply(tj, function(x) {\n      sum(d$w[d$t == x & d$f == 1])\n    })\n    \n    # Calculate the number of individuals at risk at each time point\n    nj <- sapply(tj, function(x) {\n      sum(d$w[d$t >= x])\n    })\n    \n    # Compute the cumulative product for the survival probabilities\n    st <- cumprod((nj - dj) / nj)\n    \n    # Append the results to the Kaplan-Meier table\n    table_KM <- rbind(table_KM, data.frame(T = tj, n = nj, d = dj, \n                                           S = st, variable = i))\n  }\n  return(table_KM)\n}\n\n\n# IPCW Kaplan-Meier estimator with restricted tau\nIPCW_Kaplan_meier <- function(data, tau, \n                              X.names.censoring, \n                              nuisance_censoring = \"cox\", \n                              n.folds = NULL) {\n  \n  # Compute of truncated T_obs, status and censored status\n  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)\n  data$censor.status_tau <- 1 - as.numeric((data$T_obs >= tau) | \n                                             (data$T_obs < tau & data$status == 1))\n  data$status_tau <- as.numeric((data$T_obs >= tau) | \n                                  (data$T_obs < tau & data$status == 1))\n  Y.grid <- sort(unique(data$T_obs_tau))\n  \n  # Estimate probability of remaining uncensored based on nuisance model \n  S_C_hat <- estimate_survival_function(data = data, X.names = X.names.censoring,\n                                        Y.grid = Y.grid, T_obs = \"T_obs_tau\",\n                                        status = \"censor.status_tau\",\n                                        type_of_model = nuisance_censoring,\n                                        n.folds = n.folds)\n  \n  # Select the probability of censoring for each observed T_obs_tau from the \n  # curve\n  data$S_C <- S_C_hat$S_hat[cbind(1:nrow(data), match(data$T_obs_tau, Y.grid))]\n  \n  # Compute IPC weights\n  data$weights <- data$status_tau / data$S_C\n  \n  # Compute the adjusted IPCW Kaplan-Meier\n  S <- adjusted.KM(times = data$T_obs, failures = data$status, \n                   variable = data$A, weights = data$weights)\n\n  # Compute differenceof RMST between the two groups\n  RMST <- RMST_1(S_A1 = S[S$variable == 1,], S_A0 = S[S$variable == 0,], tau = tau)\n  \n  return(list(RMST = RMST$RMST,\n              intA1 = RMST$intA1,\n              intA0 = RMST$intA0,\n              weights = data$weights))\n}\n\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Alternative code to estimate IPCW Kaplan-Meier, IPTW Kaplan-Meier or \n# IPTW-IPCW Kaplan-Meier estimator with survival package instead of using \n# handmade adjusted.KM function (the weights need to be calculated before).\n\n# Weights0 corresponds to weights of the control and weights1 of treated\nAdjusted_Kaplan_meier_alternative <- function(data, A1 = 1, A0 = 0, tau, \n                                          weights0, weights1){\n  # Estimate Kaplan-Meier estimator with survfit function on data subset \n  # Groupe A = 0\n  fit0 <- survfit(Surv(T_obs, status) ~ 1, data = data[data$A == A0,], weights = weights0)  \n  # Groupe A = 1\n  fit1 <- survfit(Surv(T_obs, status) ~ 1, data = data[data$A == A1,], weights = weights1)  \n\n  # Estimate the RMST with rmean\n  summary_fit0 <- summary(fit0, rmean = tau)  # RMST for A = 0\n  summary_fit1 <- summary(fit1, rmean = tau)  # RMST for A = 1\n\n  # Extract the RMST from the summary objects\n  rmst0 <- summary_fit0$table[\"rmean\"][[1]]\n  rmst1 <- summary_fit1$table[\"rmean\"][[1]]\n\n  # Compute the difference in RMST between the two groups\n  difference_rmst <- rmst1 - rmst0\nreturn(difference_rmst)\n}\n```\n\nThis alternative approach for IPCW Kaplan-Meier would also be valid for IPTW and IPTW-IPCW Kaplan-Meier.\n\n**Buckley-James based estimator **\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Compute the Restricted Mean Survival Time (RMST) difference\nBJ <- function(data, tau, X.names.outcome = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n               nuisance = \"cox\", n.folds = NULL) {\n  # Truncate observed times at tau\n  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)\n  Y.grid <- sort(unique(data$T_obs_tau))\n  \n  # Censoring status at tau\n  data$status_tau <- as.numeric((data$T_obs >= tau) | \n                                (data$T_obs < tau & data$status == 1))\n  \n  # Compute Q_t for all time points\n  Q_t <- Q_t_hat(data, tau, X.names.outcome, nuisance, n.folds)\n  data$Q_y <- Q_Y(data, tau, Q_t)\n  \n  # Split data by treatment group\n  data_treated <- data %>% dplyr::filter(A == 1)\n  data_not_treated <- data %>% dplyr::filter(A == 0)\n  \n  # Calculate Restricted Survival Time (RST) for each group\n  data_treated$RST <- data_treated$status_tau * data_treated$T_obs_tau + \n                      (1 - data_treated$status_tau) * data_treated$Q_y\n  \n  data_not_treated$RST <- data_not_treated$status_tau * data_not_treated$T_obs_tau + \n                          (1 - data_not_treated$status_tau) * data_not_treated$Q_y\n  \n  # Calculate RMST difference between treated and not treated\n  RMST <- mean(data_treated$RST) - mean(data_not_treated$RST)\n  \n  # Return RMST and other relevant metrics\n  return(list(\n    RMST = RMST, \n    ATE_treated = mean(data_treated$RST), \n    ATE_not_treated = mean(data_not_treated$RST)\n  ))\n}\n```\n\n**IPTW Kaplan-Meier**\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Function to calculate IPTW Kaplan-Meier\nIPTW_Kaplan_meier <- function(data, tau, X.names.propensity, \n                              nuisance_propensity = \"glm\", n.folds = NULL) {\n  # Estimate propensity scores\n  data$e_hat <- estimate_propensity_score(\n    data,\n    treatment_covariates = X.names.propensity,\n    type_of_model = nuisance_propensity,\n    n.folds = n.folds)\n  \n  # Truncate observed times at tau\n  data$T_obs_tau <- pmin(data$T_obs, tau)\n  \n  # Define censoring status at tau\n  data$status_tau <- as.numeric((data$T_obs >= tau) | \n                                (data$T_obs < tau & data$status == 1))\n  \n  # Calculate weights\n  data$weights <- (data$A) * (1 / data$e_hat) + (1 - data$A) / (1 - data$e_hat)\n  \n  # Adjusted Kaplan-Meier estimator\n  S <- adjusted.KM(\n    times = data$T_obs, \n    failures = data$status,\n    variable = data$A, \n    weights = data$weights)\n  \n  # Calculate RMST from the adjusted survival curves\n  RMST <- RMST_1(S_A1 = S[S$variable == 1,], \n                 S_A0 = S[S$variable == 0,], \n                 tau = tau)\n  \n  return(list(\"intA0\" = RMST$intA0, \"intA1\" = RMST$intA1, \"RMST\" = RMST$RMST))\n}\n\n```\n\n**G-formula**\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Function to estimate the g-formula Two-learner.\ng_formula_T_learner <- function(data, \n                                X.names.outcome, \n                                tau, \n                                nuisance_survival = \"cox\", \n                                n.folds = NULL) {\n  # Compute min(T_obs,tau)\n  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)\n  \n  # Y.grid is the grid of time points where we want to estimate the \n  # survival function.\n  Y.grid <- sort(unique(data$T_obs_tau))\n  \n  S_hat <- estimate_survival_function(data, X.names.outcome, \n                                      Y.grid, \n                                      type_of_model = nuisance_survival,\n                                      T_obs = \"T_obs\", \n                                      status = \"status\", \n                                      n.folds = n.folds)\n  \n  # Compute the area under each survival curve up to max(Y.grid) = tau.\n  E_hat1 <- expected_survival(S_hat$S_hat1, Y.grid)\n  E_hat0 <- expected_survival(S_hat$S_hat0, Y.grid)\n  \n  # Calculate the mean difference.\n  theta_g_formula <- mean(E_hat1 - E_hat0)\n  \n  return(theta_g_formula)\n}\n\n# Function to estimate the g-formula Single-learner.\ng_formula_S_learner <- function(data, \n                                X.names.outcome, \n                                tau, \n                                nuisance_survival = \"cox\", \n                                n.folds = NULL) {\n  # Compute min(T_obs,tau)\n  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)\n  \n  # Y.grid is the grid of time points where we want to estimate the \n  # survival function.\n  Y.grid <- sort(unique(data$T_obs_tau))\n  \n  S_hat <- estimate_survival_function(data, X.names.outcome, \n                                      Y.grid, \n                                      type_of_model = nuisance_survival,\n                                      learner = \"S-learner\",\n                                      T_obs = \"T_obs\", \n                                      status = \"status\", \n                                      n.folds = n.folds)\n  \n  # Compute the area under each survival curve until max(Y.grid) = tau.\n  E_hat1 <- expected_survival(S_hat$S_hat1, Y.grid)\n  E_hat0 <- expected_survival(S_hat$S_hat0, Y.grid)\n  \n  # Calculate the mean difference.\n  theta_g_formula <- mean(E_hat1 - E_hat0)\n  \n  return(theta_g_formula)\n}\n\n```\n\n**IPTW-IPCW Kaplan-Meier**\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nIPTW_IPCW_Kaplan_meier <- function(data, \n                                   X.names.propensity, \n                                   X.names.censoring, \n                                   tau,\n                                   nuisance_propensity = \"glm\",\n                                   nuisance_censoring = \"cox\",\n                                   n.folds = NULL) {\n  # Censoring time to tau if observed time exceeds tau\n  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)\n  \n  # Create censoring status for tau\n  data$censor.status_tau <- 1 - as.numeric((data$T_obs >= tau) | \n                                           (data$T_obs < tau & data$status == 1))\n  \n  # Create status at tau\n  data$status_tau <- as.numeric((data$T_obs >= tau) | \n                                (data$T_obs < tau & data$status == 1))\n  \n  # Grid of unique observed times truncated at tau\n  Y.grid <- sort(unique(data$T_obs_tau))\n\n  # Estimate propensity scores\n  data$e_hat <- estimate_propensity_score(data,\n                                          treatment_covariates = X.names.propensity,\n                                          type_of_model = nuisance_propensity,\n                                          n.folds = n.folds)\n\n  # Estimate survival function for censoring\n  S_C_hat <- estimate_survival_function(data, X.names = X.names.censoring,\n                                        Y.grid = Y.grid, T_obs = \"T_obs_tau\",\n                                        status = \"censor.status_tau\",\n                                        type_of_model = nuisance_censoring,\n                                        n.folds = n.folds)\n\n  # Get estimated survival probabilities for censoring\n  data$S_C <- S_C_hat$S_hat[cbind(1:nrow(data), match(data$T_obs_tau, Y.grid))]\n\n  # Calculate weights\n  data$weights <- data$status_tau / data$S_C * \n                  (data$A * (1 / data$e_hat) + \n                     (1 - data$A) * (1 / (1 - data$e_hat)))\n\n  # Compute adjusted Kaplan-Meier estimator\n  S <- adjusted.KM(times = data$T_obs, \n                   failures = data$status, \n                   variable = data$A, \n                   weights = data$weights)\n\n  # Compute Restricted Mean Survival Time (RMST)\n  RMST <- RMST_1(S_A1 = S[S$variable == 1, ], \n                 S_A0 = S[S$variable == 0, ],\n                 tau = tau)\n\n  # Return RMST and ATE for treated and not treated groups\n  return(list(RMST = RMST$RMST, ATE_treated = RMST$intA1, \n              ATE_not_treated = RMST$intA0))\n}\n```\n\n**IPTW-BJ estimator**\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nIPTW_BJ <- function(data, \n                    X.names.propensity,\n                    X.names.outcome, \n                    tau,\n                    nuisance_propensity = \"glm\",\n                    nuisance = \"cox\",\n                    n.folds = NULL) {\n  # Minimum of T_obs and tau\n  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)\n  \n  # Grid of unique observed times truncated at tau\n  Y.grid <- sort(unique(data$T_obs_tau))\n  \n  # Indicator for min(T, tau) < C\n  data$status_tau <- as.numeric((data$T_obs >= tau) | \n                                (data$T_obs < tau & data$status == 1))\n  \n\n  # Estimate propensity scores\n  data$e_hat <- estimate_propensity_score(data,\n                                          treatment_covariates = X.names.propensity,\n                                          type_of_model = nuisance_propensity,\n                                          n.folds = n.folds)\n\n\n  # Estimation of Q_s\n  Q_t <- Q_t_hat(data, tau, X.names.outcome, nuisance, n.folds)\n  data$Q_y <-  Q_Y(data,tau,Q_t)\n  \n  # BJ transformation\n  data$Y <-  data$status_tau * data$T_obs_tau + \n                             (1 - data$status_tau) * data$Q_y\n  \n  # IPTW on BJ transformation \n  data$RST <- data$Y * (data$A/data$e_hat-(1-data$A)/(1-data$e_hat))\n  \n  RMST <- mean(data$RST)\n  \n  # Return RMST\n  return(RMST)\n}\n```\n\n**AIPTW-AIPCW**\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# DR censoring transformation\nAIPCW <-function(data,\n                 tau,\n                 X.names.censoring = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n                 X.names.outcome = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n                 nuisance_Qt = \"cox\",\n                 nuisance_censoring = \"cox\", \n                 n.folds = NULL, \n                 h_C_hat = NULL,\n                 method_aipw = 1) {\n  \n  # Truncate observed times at tau\n  data$T_obs_tau <- pmin(data$T_obs, tau)\n  \n  # Define status at tau\n  data$status_tau <-  as.numeric((data$T_obs > tau) | \n                                  (data$T_obs <= tau &  data$status == 1 ))  \n\n  data$censor.status_tau <- 1- as.numeric(\n    (data$T_obs > tau) | (data$T_obs <= tau &  data$status == 1 ))\n \n  Y.grid <- sort(unique(data$T_obs_tau))\n  \n  # Estimate survival function for censoring\n  S_C_hat <- estimate_survival_function(data = data,X.names.censoring,\n                                        type_of_model = nuisance_censoring,\n                                        n.folds = n.folds,\n                                        Y.grid = Y.grid,\n                                        T_obs = \"T_obs_tau\",\n                                        status = \"censor.status_tau\")\n  \n  Y.index <- findInterval(data$T_obs_tau, Y.grid)\n  \n  data$S_C_hat_T_obs_tau <- S_C_hat$S_hat[cbind(seq_along(Y.index), Y.index)]\n\n  \n  if (is.null(h_C_hat)) {\n      h_C_hat <- estimate_hazard_function(S_C_hat$S_hat,Y.grid)\n  } \n  \n  # Compute Q.t.hat\n  Q.t.hat <- Q_t_hat(data = data,\n                     X.names = X.names.outcome,\n                     tau = tau,\n                     nuisance = nuisance_Qt,\n                     n.folds = n.folds)\n  \n  # Compute Q.Y.hat\n  data$Q.Y.hat <- Q_Y(data = data, tau, Q.t.hat)\n\n  # Compute first term\n  data$first_term <- (data$T_obs_tau * data$status_tau) / \n    data$S_C_hat_T_obs_tau\n  \n  # Compute second term\n  data$second_term <- (data$Q.Y.hat * (1 - data$status_tau)) / \n    data$S_C_hat_T_obs_tau\n  \n  Y.diff <- diff(c(0, Y.grid))\n  \n  # Compute integrand for the third term\n  integrand <- sweep( ( (h_C_hat) / S_C_hat$S_hat )* (Q.t.hat), 2, Y.diff, \"*\")\n  \n  # Compute third term\n  data$third_term <- integrate(integrand, Y.grid, data$T_obs_tau)\n  \n  # Compute pseudo outcome\n  pseudo_outcome <- data$first_term + data$second_term - data$third_term\n\n  return(pseudo_outcome) \n}\n\n\nAIPTW_AIPCW <- function(data, \n                        tau, \n                        X.names.propensity = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n                        X.names.censoring = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n                        X.names.outcome = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n                        nuisance_propensity = \"glm\",\n                        nuisance_regression = \"cox\",\n                        nuisance_censoring = \"cox\",\n                        nuisance_Qt = \"cox\",\n                        n.folds = NULL) {\n  \n  # Estimate propensity scores\n  data$e_hat <- estimate_propensity_score(\n    data = data, \n    treatment_covariates = X.names.propensity, \n    type_of_model = nuisance_propensity, \n    n.folds = n.folds\n  )\n  \n  # Prepare data for censoring model\n  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)\n  \n  data$censor.status_tau <- 1 - as.numeric((data$T_obs >= tau) | \n                                             (data$T_obs < tau & data$status == 1))\n  \n  data$status_tau <- as.numeric((data$T_obs >= tau) | \n                                  (data$T_obs < tau & data$status == 1))\n  \n  # Create unique time grid\n  Y.grid <- sort(unique(data$T_obs_tau))\n  \n  S_hat <- estimate_survival_function(data, X.names.outcome, \n                                      type_of_model = nuisance_regression, \n                                      Y.grid = Y.grid,\n                                      T_obs= \"T_obs\", \n                                      status = \"status\", \n                                      n.folds = n.folds)\n  \n  # Compute area under the survival curve up to tau\n  data$E_hat1 <- expected_survival(S_hat$S_hat1, Y.grid)\n  data$E_hat0 <- expected_survival(S_hat$S_hat0, Y.grid)\n  \n  # Compute IPW-weighted residuals\n  data$IPW_res <- data$E_hat1 * (1 - data$A / data$e_hat) - \n    data$E_hat0 * (1 - (1 - data$A) / (1 - data$e_hat))\n  \n  # Compute AIPCW weights\n  TDR <- AIPCW(\n    data = data, \n    tau = tau,\n    X.names.censoring = X.names.censoring,\n    X.names.outcome = X.names.outcome,\n    nuisance_Qt = nuisance_Qt, \n    nuisance_censoring = nuisance_censoring, \n    n.folds = n.folds\n  )\n  \n  data$TDR <- TDR\n  \n  # Compute AIPCW-weighted residuals\n  data$AIPCW_w <- data$TDR * (data$A / data$e_hat - \n                                (1 - data$A) / (1 - data$e_hat))\n  \n  # Compute regression residuals\n  data$reg <- data$E_hat1 - data$E_hat0\n  data$reg_res <- data$A / data$e_hat * (data$TDR - data$E_hat1) - \n    (1 - data$A) / (1 - data$e_hat) * (data$TDR - data$E_hat0)\n  \n  # Compute estimators\n  # na.rm = TRUE to remove NA for the mean calculation\n  AIPTW_AIPCW_IPW_res <- mean(data$AIPCW_w + data$IPW_res, na.rm = TRUE)\n  AIPTW_AIPCW_reg_res <- mean(data$reg + data$reg_res, na.rm = TRUE)\n  \n  return(list(AIPTW_AIPCW_reg_res = AIPTW_AIPCW_reg_res, \n              AIPTW_AIPCW_IPW_res = AIPTW_AIPCW_IPW_res))\n}\n\n```\n\n# Simulations\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n############ RCT \n# RCT1:  Random treatment assignment + independent censoring\n# RCT2:  Random treatment assignment + dependent censoring (conditional on X \n# and A)\nsimulate_data_RCT <- function(n, mu = c(1, 1, -1, 1), \n                              sigma = diag(4), \n                              colnames_cov = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n                              tau, \n                              coefT0 = 0.01,\n                              parsS = c(0.5, 0.5, -0.5, 0.5), \n                              coefC = 0.03,\n                              parsC = c(0.7, 0.3, -0.25, -0.1), \n                              parsC_A = c(-0.2), \n                              scenario = \"RCT2\",\n                              mis_specification=\"none\") {\n  \n  # Generate X from a multivariate normal distribution\n  X <- MASS::mvrnorm(n, mu, sigma)\n  X <- as.data.frame(X)\n  colnames(X) <- colnames_cov\n  \n  # Treatment variable selection: all X\n  X_treatment <- as.matrix(X)\n  \n  # Propensity score: constant for random assignment\n  e <- rep(0.5, n)\n  \n  # Random treatment assignment\n  A <- sapply(e, FUN = function(p) rbinom(1, 1, p))\n  \n  # Outcome variable selection: all X\n  X_outcome <- as.matrix(X)\n  \n  # Simulate the outcome using the cumulative hazard inversion method\n  epsilon <- runif(n, min = 1e-8, max = 1)\n  T0 <- -log(epsilon) / (coefT0 * exp(X_outcome %*% parsS))\n  \n  if (scenario == \"RCT1\") {\n    # Simulate independent censoring time\n    epsilon <- runif(n, min = 1e-8, max = 1)\n    C <- -log(epsilon) / coefC\n  }\n  else if (scenario == \"RCT2\") {\n    # Simulate dependent censoring time\n    X_censoring <- as.matrix(cbind(X,A))\n    parsC <- c(parsC,parsC_A)\n    \n    epsilon <- runif(n, min = 1e-8, max = 1)\n    C <- -log(epsilon) / (coefC * exp(rowSums(X_censoring %*% diag(parsC))))\n  }\n  # T(1) = T(0) + 10\n  T1 <- T0 + 10\n  \n  # True survival time\n  T_true <- A * T1 + (1 - A) * T0\n  \n  # Observed time\n  T_obs <- pmin(T_true, C)\n  \n  # Status indicator\n  status <- as.numeric(T_true <= C)\n  censor.status <- as.numeric(T_true > C)\n  \n  # Restricted survival time\n  T_obs_tau <- pmin(T_obs, tau)\n  status_tau <- as.numeric((T_obs > tau) | (T_obs <= tau & status == 1))\n  \n  # Combine all data into a single data frame\n  data_target_population <- data.frame(X, tau, A, T0, T1, C, T_obs, T_obs_tau, \n                                       status, censor.status, status_tau, e)\n  \n  return(data_target_population)\n}\n\n```\n\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# data_rct1 simulate the data from RCT with independent censoring \ndata_rct1 <- simulate_data_RCT(n=2000,\n                               tau=25,\n                               scenario=\"RCT1\",\n                               coefC = 0.03)\n# Stratification by treatment \ngroup_0 <- data_rct1 %>%\n  dplyr:: filter(A == 0)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,T_tild=T_obs)\n\ngroup_1 <- data_rct1 %>%\n  dplyr:: filter(A == 1)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,T_tild=T_obs)\n\n# Summary statistics\nsummary_group_0 <- summary(group_0)\nsummary_group_1 <- summary(group_1)\n\nprint(paste(\"Descriptive statistics for group A=0:  \",nrow(group_0)))\nprint(summary_group_0)\n\nprint(paste(\"Descriptive statistics for group A=1:  \",nrow(group_1)))\nprint(summary_group_1)\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n\n# data_rct2 simulate the data from RCT with dependent censoring \ndata_rct2 <- simulate_data_RCT(n=2000,\n                               tau=25,\n                               scenario=\"RCT2\", \n                               coefC = 0.03, \n                               parsC = c(0.7,0.3,-0.25,-0.1),\n                               parsC_A = c(-0.2))\n\n\n# Stratification by treatment \ngroup_0 <- data_rct2 %>%\n  dplyr:: filter(A == 0)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,status_tau,T_tild=T_obs)\n\ngroup_1 <- data_rct2 %>%\n  dplyr:: filter(A == 1)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,status_tau,T_tild=T_obs)\n\n# Summary statistics\nsummary_group_0 <- summary(group_0)\nsummary_group_1 <- summary(group_1)\n\nprint(paste(\"Descriptive statistics for group A=0:  \",nrow(group_0)))\nprint(summary_group_0)\n\nprint(paste(\"Descriptive statistics for group A=1:  \",nrow(group_1)))\nprint(summary_group_1)\n\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Function to calculate ground truth for RCT and Observational data\nground_truth <- function(tau, \n                         data) {\n  # Compute RMST with the true T1\n  data$T1_tau <- ifelse(data$T1 >= tau, tau, data$T1)\n  \n  # Compute RMST with the true T0\n  data$T0_tau <- ifelse(data$T0 >= tau, tau, data$T0)\n  \n  # Compute the difference in RMST if everyone had the treatment \n  # and if everyone had the control\n  truth <- mean(data$T1_tau) - mean(data$T0_tau)\n  \n  return(truth)\n}\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Set initial tau value\ntau <- 25\n# Define vector of tau values\nvec_tau <- seq(1, 150, by = 1)\n\n# Function to plot the ground truth RMST for different scenarios\nplot_ground_truth <- function(data, vec_tau, tau, ylim, title_text) {\n  truth <- sapply(vec_tau, function(x) ground_truth(tau = x, data))\n  matplot(\n    vec_tau, truth, type = \"l\", lty = 1, col = 1,\n    ylab = \"RMST\", xlab = \"tau\", ylim = ylim\n  )\n  abline(v = tau, col = \"red\", lty = 2)\n  abline(h = truth[vec_tau == tau], col = \"red\", lty = 2)\n  title(title_text, cex.main = 0.9)  # Adjusting title text size\n}\n\n# Simulation for scenario RCT1\ndata_RCT1 <- simulate_data_RCT(\n  n = 100000, tau = tau, scenario = \"RCT1\")\n\nplot_ground_truth(data_RCT1, \n                  vec_tau, \n                  tau, \n                  c(0, 10), \n                  \"True difference in RMST for RCT scenario 1\")\n\ntruth_tau1 <- ground_truth(data_RCT1, tau = 25)\nprint(paste0(\"The ground truth for RCT scenario 1 and 2 at time 25 is \", round(truth_tau1, 1)))\ntruth_tau2 <- truth_tau1\n```\n\n\n```{r}\n# Function to launch the previous implemented functions in a \n# specified scenario, sample size.\nall_estimates <- function(data, sample.size, tau, \n                           X.names.propensity,\n                           X.names.censoring,\n                           X.names.outcome,\n                           nuisance_propensity = \"glm\", \n                           nuisance_censoring = \"cox\", \n                           nuisance_survival = \"cox\", \n                           n.folds = NULL,\n                           estimator = \"all\") {\n  \n  # List of available estimators\n  available_estimators <- c(\n    \"Naive\", \"KM\", \"IPTW KM\", \"IPCW KM\", \"BJ\", \n    \"IPTW-IPCW KM\", \"IPTW-BJ\", \"G_formula (T-learners)\", \n    \"G_formula (S-learner)\", \"AIPTW-AIPCW\", \"SurvRM2 - KM\", \n    \"grf - Causal Survival Forest\", \"RISCA - IPTW KM\", \n    \"RISCA - G_formula (S-learner)\"\n  )\n  \n  # If estimator is \"all\", we select all the estimators in \n  # available_estimators\n  if (\"all\" %in% estimator) {\n    estimator <- available_estimators\n  }\n  \n  # Filter the selected estimators\n  estimator <- intersect(estimator, available_estimators)\n  \n  # Store the results in a data frame\n  results <- data.frame(\n    \"sample.size\" = numeric(),\n    \"estimate\" = numeric(),\n    \"estimator\" = character(),\n    \"nuisance\" = character()\n  )\n  \n  # Function to extract variable names from I() for squared terms and interaction terms\n  extract_vars <- function(names) {\n    # Extract names from squared terms\n    extracted_squared <- gsub(\"I\\\\((.*)\\\\^2\\\\)\", \"\\\\1\", names)  # Replace \"I(X^2)\" with \"X\"\n    # Extract names from interaction terms (e.g., \"X1:X2\" becomes \"X1\" and \"X2\")\n    result_vector <- unique(unlist(strsplit(extracted_squared, \":\")))\n    return(unique(result_vector))\n  }\n  # Combine all vectors\n  all_names <- c(X.names.propensity, X.names.outcome, X.names.censoring)\n  # Apply the extraction function\n  X.names <- extract_vars(all_names)\n  \n  # Each estimator is computed if selected\n  # Naive estimator\n  if (\"Naive\" %in% estimator) {\n    ATE_naive <- Naive(data, tau)\n    results <- rbind(results, data.frame(\n      \"sample.size\" = sample.size, \"estimate\" = ATE_naive, \n      \"estimator\" = \"Naive\", \"nuisance\" = \"\"\n    ))\n  }\n  # RMST estimate with undajusted KM\n  if (\"KM\" %in% estimator) {\n    ATE_km_rct <- RMST_1(data, tau = tau)\n    results <- rbind(results, data.frame(\n      \"sample.size\" = sample.size, \"estimate\" = ATE_km_rct$RMST, \n      \"estimator\" = \"KM\", \"nuisance\" = \"\"\n    ))\n  }\n  # RMST estimate with IPTW KM\n  if (\"IPTW KM\" %in% estimator) {\n    for (propensity_method in nuisance_propensity) {\n      ATE_km_adj <- IPTW_Kaplan_meier(data, tau = tau, \n                                      X.names.propensity = X.names.propensity, \n                                      nuisance_propensity = propensity_method, \n                                      n.folds = n.folds)\n      if (propensity_method == \"probability forest\"){propensity_name = \"Forest\"}\n      else{propensity_name = \"Log. Reg.\"}\n      est_name <- paste(\"IPTW KM (\", propensity_name, \")\", sep = \"\")\n      results <- rbind(results, data.frame(\n        \"sample.size\" = sample.size, \"estimate\" = ATE_km_adj$RMST, \n        \"estimator\" = est_name, \"nuisance\" = propensity_method\n      ))\n    }\n  }\n  \n  # RMST estimate with IPCW KM\n  if (\"IPCW KM\" %in% estimator) {\n    for (censoring_method in nuisance_censoring) {\n      ATE_IPCW <- IPCW_Kaplan_meier(data, X.names.censoring = X.names.censoring, \n                                    tau = tau, \n                                    nuisance_censoring = censoring_method, \n                                    n.folds = n.folds)\n      if (censoring_method == \"survival forest\"){censoring_name = \"Forest\"}\n      else{censoring_name = \"Cox\"}\n      est_name <- paste(\"IPCW KM (\", censoring_name, \")\", sep = \"\")\n      results <- rbind(results, data.frame(\n        \"sample.size\" = sample.size, \"estimate\" = ATE_IPCW$RMST, \n        \"estimator\" = est_name , \"nuisance\" = censoring_method\n      ))\n    }\n  }\n  # RMST estimate with BJ pseudo observations\n  if (\"BJ\" %in% estimator) {\n    for (survival_method in nuisance_survival) {\n      ATE_bj <- BJ(data, tau = tau, \n                   X.names.outcome = X.names.outcome,\n                   nuisance = survival_method, \n                   n.folds = n.folds)\n      if (survival_method == \"survival forest\"){survival_name = \"Forest\"}\n      else{survival_name = \"Cox\"}\n      est_name <- paste(\"BJ (\", survival_name, \")\", sep = \"\")\n      results <- rbind(results, data.frame(\n        \"sample.size\" = sample.size, \"estimate\" = ATE_bj$RMST, \n        \"estimator\" = est_name, \"nuisance\" = survival_method\n      ))\n    }\n  }\n  \n  # RMST estimate with g-formula two-learners\n  if (\"G_formula (T-learners)\" %in% estimator) {\n    for (survival_method in nuisance_survival) {\n      ATE_g_formula_t <- g_formula_T_learner(data, tau = tau, \n                                             X.names.outcome = X.names.outcome, \n                                             nuisance_survival = survival_method, \n                                             n.folds = n.folds)\n      if (survival_method == \"survival forest\"){survival_name = \"Forest\"}\n      else{survival_name = \"Cox\"}\n      est_name <- paste(\"G-formula (\", survival_name, \"/ T-learners)\", sep = \"\")\n      results <- rbind(results, data.frame(\n        \"sample.size\" = sample.size, \"estimate\" = ATE_g_formula_t, \n        \"estimator\" = est_name, \n        \"nuisance\" = survival_method\n      ))\n    }\n  }\n  \n  # RMST estimate with g-formula single learner\n  if (\"G_formula (S-learner)\" %in% estimator) {\n    for (survival_method in nuisance_survival) {\n      ATE_g_formula_s <- g_formula_S_learner(data, tau = tau, \n                                             X.names.outcome = X.names.outcome, \n                                             nuisance_survival = survival_method, \n                                             n.folds = n.folds)\n      if (survival_method == \"survival forest\"){survival_name = \"Forest\"}\n      else{survival_name = \"Cox\"}\n      est_name <- paste(\"G-formula (\", survival_name, \"/ S-learner)\", sep = \"\")\n      results <- rbind(results, data.frame(\n        \"sample.size\" = sample.size, \"estimate\" = ATE_g_formula_s, \n        \"estimator\" = est_name, \n        \"nuisance\" = survival_method\n      ))\n    }\n  }\n  \n  \n  # RMST estimate with IPTW with pseudo observations (BJ transformation)\n  if (\"IPTW-BJ\" %in% estimator) {\n    for (survival_method in nuisance_survival) {\n      for (propensity_method in nuisance_propensity) {\n        ATE_IPTW_bj <- IPTW_BJ(data, tau = tau, \n                               X.names.propensity = X.names.propensity, \n                               X.names.outcome = X.names.outcome, \n                               nuisance_propensity = propensity_method, \n                               nuisance = survival_method, \n                               n.folds = n.folds)\n        if (survival_method == \"survival forest\"){survival_name = \"Forest\"}\n        else{survival_name = \"Cox\"}\n        if (propensity_method == \"probability forest\"){propensity_name = \"Forest\"}\n        else{propensity_name = \"Log. Reg.\"}\n        if (propensity_name  == survival_name){\n          est_name <- paste(\"IPTW-BJ (\", survival_name, \")\", sep = \"\")\n        }\n        else{\n          est_name <- paste(\"IPTW-BJ (\", survival_name,\" & \", propensity_name , \")\", \n                            sep = \"\")}\n        \n        \n        results <- rbind(results, data.frame(\n          \"sample.size\" = sample.size, \"estimate\" = ATE_IPTW_bj, \n          \"estimator\" = est_name, \n          \"nuisance\" = paste(survival_method, propensity_method, sep = \", \")\n        ))\n      }\n    }\n  }\n  \n  # RMST estimate with IPTW-IPCW KM\n  if (\"IPTW-IPCW KM\" %in% estimator) {\n    for (censoring_method in nuisance_censoring) {\n      for (propensity_method in nuisance_propensity) {\n        ATE_iptw_ipcw_km <- IPTW_IPCW_Kaplan_meier(data, tau = tau, \n                                                   X.names.propensity = X.names.propensity, \n                                                   X.names.censoring = X.names.censoring, \n                                                   nuisance_propensity = propensity_method, \n                                                   nuisance_censoring = censoring_method, \n                                                   n.folds = n.folds)\n        if (censoring_method == \"survival forest\"){censoring_name = \"Forest\"}\n        else{censoring_name = \"Cox\"}\n        if (propensity_method == \"probability forest\"){propensity_name = \"Forest\"}\n        else{propensity_name = \"Log. Reg.\"}\n        if (propensity_name  == censoring_name){\n          est_name <- paste(\"IPTW-IPCW KM (\", censoring_name , \")\", \n                            sep = \"\")\n        }\n        else{\n          est_name <- paste(\"IPTW-IPCW KM (\", censoring_name,\" & \", propensity_name , \")\", \n                            sep = \"\")}\n        results <- rbind(results, data.frame(\n          \"sample.size\" = sample.size, \"estimate\" = ATE_iptw_ipcw_km$RMST, \n          \"estimator\" = est_name, \n          \"nuisance\" = paste(censoring_method, propensity_method, sep = \", \")\n        ))\n      }\n    }\n  }\n  \n  \n  # RMST estimate with AIPTW with pseudo observations (AIPCW transformation)\n  if (\"AIPTW-AIPCW\" %in% estimator) {\n    for (survival_method in nuisance_survival) {\n      for (propensity_method in nuisance_propensity) {\n        for (censoring_method in nuisance_censoring) {\n          ATE_aiptw_aipcw <- AIPTW_AIPCW(data, tau = tau, \n                                         X.names.propensity = X.names.propensity, \n                                         X.names.censoring = X.names.censoring, \n                                         X.names.outcome = X.names.outcome,\n                                         nuisance_propensity = propensity_method, \n                                         nuisance_censoring = censoring_method, \n                                         nuisance_Qt = survival_method, \n                                         n.folds = n.folds)\n          if (survival_method == \"survival forest\"){survival_name = \"Forest\"}\n          else{survival_name = \"Cox\"}\n          if (propensity_method == \"probability forest\"){\n            propensity_name = \"Forest\"}\n          else{propensity_name = \"Log. Reg.\"}\n          if (censoring_method == \"survival forest\"){\n            censoring_name = \"Forest\"}\n          else{censoring_name = \"Cox\"}\n          if (censoring_name == propensity_name & censoring_name == survival_name){\n            est_name <- paste(\"AIPTW-AIPCW (\", survival_name, \")\", sep = \"\")\n          }\n          else{\n            est_name <- paste(\"AIPTW-AIPCW (\", survival_name,\" & \", \n                              censoring_name ,\" & \", propensity_name , \")\", sep = \"\")}\n          results <- rbind(results, data.frame(\n            \"sample.size\" = sample.size, \n            \"estimate\" = ATE_aiptw_aipcw$AIPTW_AIPCW_IPW_res, \n            \"estimator\" = est_name, \n            \"nuisance\" = paste(survival_method, \n                               censoring_method, \n                               propensity_method , sep = \", \")\n          ))\n        }\n      }\n    }\n  }\n  \n  # Unadjusted estimate using package from SurvRM2\n  if (\"SurvRM2 - KM\" %in% estimator) {\n    ATE_pack <- tryCatch({\n      theta_rmst_survrm2(data, tau = tau)\n    }, error = function(e) {\n      message(\"Error in ATE_pack: \", e$message)\n      return(NA) \n    })\n    results <- rbind(results, data.frame(\n      \"sample.size\" = sample.size, \"estimate\" = ATE_pack, \n      \"estimator\" = \"SurvRM2 - KM\", \"nuisance\" = \"\"\n    ))\n  }\n  # Estimate using survival random forest from grf\n  # CSF can have a misspecification only on all nuisance parameters\n  if (\"grf - Causal Survival Forest\" %in% estimator) {\n    ATE_RF <- tryCatch({\n      # If there is no misspecification, X.names has to be defined as the \n      # union of all the covariates which influence nuisance models\n      CSRF(data, X.names, tau = tau)\n    }, error = function(e) {\n      message(\"Error in ATE_RF: \", e$message)\n      return(NA) \n    })\n    results <- rbind(results, data.frame(\n      \"sample.size\" = sample.size, \"estimate\" = ATE_RF, \n      \"estimator\" = \"grf - Causal Survival Forest\", \n      \"nuisance\" = \"\"\n    ))\n  }\n  \n  if (\"RISCA - IPTW KM\" %in% estimator) {\n    for (propensity_method in nuisance_propensity) {\n      # IPTW estimate from RISCA\n      ATE_RISCA_iptw <- tryCatch({\n        RISCA_iptw(data, X.names.propensity, propensity_method, tau = tau, \n                   n.folds=n.folds)\n      }, error = function(e) {\n        message(\"Error in ATE_RISCA_iptw: \", e$message)\n        return(NA) \n      })\n      if (propensity_method == \"probability forest\"){propensity_name = \"Forest\"}\n      else{propensity_name = \"Log. Reg.\"}\n      est_name <- paste(\"RISCA - IPTW KM (\", propensity_name, \")\", sep = \"\")\n      results <- rbind(results, data.frame(\n        \"sample.size\" = sample.size, \"estimate\" = ATE_RISCA_iptw, \n        \"estimator\" = est_name, \n        \"nuisance\" = propensity_method\n      ))\n    }\n  }\n  # Only support Cox object\n  if (\"RISCA - G_formula (S-learner)\" %in% estimator) {\n    # G-formula estimate from RISCA\n    ATE_RISCA_gf <- tryCatch({\n      RISCA_gf(data, X.names.outcome, tau = tau)\n    }, error = function(e) {\n      message(\"Error in ATE_RISCA_gf: \", e$message)\n      return(NA) \n    })\n    results <- rbind(results, data.frame(\n      \"sample.size\" = sample.size, \"estimate\" = ATE_RISCA_gf, \n      \"estimator\" = \"RISCA - G_formula (S-learner)\", \n      \"nuisance\" = \"Cox\"\n    ))\n  }\n  return(results)\n}\n\n\n# Function to compute estimators for multiple simulations and sample sizes\ncompute_estimator <- function(n_sim, tau, scenario = \"RCT1\", \n                              X.names.propensity, \n                              X.names.outcome,\n                              X.names.censoring,\n                              nuisance_propensity = \"glm\", \n                              nuisance_censoring = \"cox\", \n                              nuisance_survival = \"cox\", \n                              n.folds_propensity = NULL,\n                              n.folds_censoring = NULL, \n                              n.folds_survival = NULL, coefC = NULL, \n                              parsC = NULL,\n                              parsC_A = NULL,\n                              estimator = \"all\",\n                              sample_sizes = c(500, 1000, 2000, 4000, 8000)) {\n  \n  pb_n <- txtProgressBar(min = 0, max = length(sample_sizes), \n                         style = 3, initial = 0, char = \"#\")\n  on.exit(close(pb_n))\n  \n  results <- data.frame(\n    \"sample.size\" = numeric(),\n    \"estimate\" = numeric(),\n    \"estimator\" = character(),\n    \"nuisance\" = character()\n  )\n  \n  # Loop through each sample size\n  for (idx_n in seq_along(sample_sizes)) {\n    n <- sample_sizes[idx_n]\n    \n    # Progress bar for simulations\n    pb <- txtProgressBar(min = 0, max = n_sim, style = 3, initial = 0, char = \"#\")\n    on.exit(close(pb))\n    \n    # Loop through each simulation\n    for (i in 1:n_sim) {\n      setTxtProgressBar(pb, i)\n      \n      # Simulate data based on the scenario\n      if (scenario == \"RCT1\") {\n        data <- simulate_data_RCT(n, tau = tau, \n                                  scenario = \"RCT1\")\n      } else if (scenario == \"RCT2\") {\n        data <- simulate_data_RCT(n, tau = tau, \n                                  scenario = \"RCT2\", \n                                  coefC = coefC, \n                                  parsC = parsC,\n                                  parsC_A = parsC_A)\n      } else if (scenario == \"Obs1\") {\n        data <- simulate_data_obs(n, tau = tau, \n                                  scenario = \"Obs1\")\n      } else if (scenario == \"Obs2\") {\n        data <- simulate_data_obs(n, tau = tau, \n                                  scenario = \"Obs2\", \n                                  coefC = coefC, \n                                  parsC = parsC)\n      } else if (scenario == \"Complex\") {\n        data <- simulate_data_complex(n, \n                                      tau = tau,\n                                      parsC = parsC)\n      } else if (scenario == \"Mis\") {\n        data <- simulate_data_mis(n, tau = tau)\n      }\n      \n      \n      # Compute all estimates for the simulated data\n      all <- all_estimates(data, n, tau = tau, \n                           X.names.propensity, \n                           X.names.outcome,\n                           X.names.censoring,\n                           nuisance_propensity, \n                           nuisance_censoring,\n                           nuisance_survival, \n                           n.folds_propensity = n.folds_propensity, \n                           n.folds_censoring = n.folds_censoring, \n                           n.folds_survival = n.folds_survival,\n                           estimator)\n      results <- rbind(all, results)\n    }\n    \n    close(pb)\n    setTxtProgressBar(pb_n, idx_n)\n  }\n  \n  return(results)\n}\n\n```\n\n\n\n```{r,eval=FALSE}\n# Number of simulations and tau value\nn_sim <- 100\ntau <- 25\n\n# RCT1 simulation\nsimulation_rct1 <- compute_estimator(\n      n_sim, tau = tau, scenario = \"RCT1\", \n      X.names.propensity = c(\"X1\", \"X2\", \"X3\", \"X4\"), \n      X.names.outcome = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n      X.names.censoring = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n      nuisance_propensity = c(\"glm\", \"probability forest\"), \n      nuisance_censoring = c(\"cox\", \"survival forest\"), \n      nuisance_survival = c(\"cox\", \"survival forest\"), \n      n.folds_propensity = 5,\n      n.folds_censoring = 5,\n      n.folds_survival = 5,\n      coefC = 0.03\n)\nsave(simulation_rct1, file = \"simulation_rct1.RData\")\n\n# RCT2 simulation with specific coefficients and parameters\nsimulation_rct2 <- compute_estimator(\n  n_sim, tau = tau, scenario = \"RCT2\", \n  X.names.propensity = c(\"X1\", \"X2\", \"X3\", \"X4\"), \n  X.names.outcome = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n  X.names.censoring = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n  nuisance_propensity = c(\"glm\", \"probability forest\"), \n  nuisance_censoring = c(\"cox\", \"survival forest\"), \n  nuisance_survival = c(\"cox\", \"survival forest\"), \n  n.folds_propensity = 5,\n  n.folds_censoring = 5,\n  n.folds_survival = 5,\n  coefC = 0.03, \n  parsC = c(0.7, 0.3, -0.25, -0.1), \n  parsC_A = 0\n)\nsave(simulation_rct2, file = \"simulation_rct2.RData\")\n\n```\n\n```{r}\nload(\"simulations/simulation_rct1.RData\")\nload(\"simulations/simulation_rct2.RData\")\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Update the theme to center the plot title\ntheme_update(plot.title = element_text(hjust = 0.5))\n\n# Define the desired order of the estimators\n\ndesired_order <- c(\n  \"Naive\",\n  \"KM\",\n  \"SurvRM2 - KM\",\n  \"IPTW KM (Log. Reg.)\",\n  \"RISCA - IPTW KM (Log. Reg.)\",\n  \"IPCW KM (Cox)\",\n  \"BJ (Cox)\",\n  \"IPTW-BJ (Cox & Log. Reg.)\",\n  \"IPTW-IPCW KM (Cox & Log. Reg.)\",\n  \"G-formula (Cox/ T-learners)\",\n  \"G-formula (Cox/ S-learner)\",\n  \"RISCA - G_formula (S-learner)\",\n  \"AIPTW-AIPCW (Cox & Cox & Log. Reg.)\",\n  \"grf - Causal Survival Forest\",\n  \"IPTW KM (Forest)\",\n  \"RISCA - IPTW KM (Forest)\",\n  \"IPCW KM (Forest)\",\n  \"BJ (Forest)\",\n  \"IPTW-BJ (Forest)\",\n  \"IPTW-IPCW KM (Forest)\",\n  \"G-formula (Forest/ T-learners)\",\n  \"G-formula (Forest/ S-learner)\",\n  \"AIPTW-AIPCW (Forest)\")\n\n# Convert sample size to a factor with levels sorted in decreasing order\nsimulation_rct1$sample.size <- factor(\n  simulation_rct1$sample.size, \n  levels = sort(unique(simulation_rct1$sample.size), decreasing = FALSE)\n)\n\n# Convert estimator column to a factor with the specified order\nsimulation_rct1$estimator <- factor(simulation_rct1$estimator, \n                                    levels = desired_order)\n\n# Create the plot for RCT + independent censoring\nsimulation_graph_rct1 <- simulation_rct1 %>%\n  ggplot(aes(\n    x = estimator, y = estimate,  \n    fill = factor(sample.size, levels = rev(levels(sample.size)))\n  )) +\n  scale_fill_brewer(palette = \"Accent\") +\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +  # Change x-axis label\n  ylab(\"ATE\") +  # Change y-axis label\n  stat_boxplot(geom = \"errorbar\") +\n  geom_hline(\n    yintercept = truth_tau1, linetype = \"dashed\", color = \"red\", \n    alpha = 0.8, size = 0.8\n  ) +\ntheme(\n    legend.title = element_blank(), legend.position = \"bottom\",\n    legend.box = \"vertical\", legend.text = element_text(size = 18),\n    axis.text.x = element_text(angle = 35, vjust = 1, hjust = 1),  \n    # Adjust text angle for better visibility\n    axis.text = element_text(size = 15, face = \"bold\"),\n    axis.title.x = element_text(size = 16, face = \"bold\"),\n    plot.margin = margin(t = 10, r = 10, b = 50, l = 10)  # Add margin\n  ) +    \n  coord_cartesian(ylim = c(0, 15))\n  \n```\n\n```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}\n#| label: fig-rct1\n#| fig-cap: \"Results of the ATE for the simulation of a RCT with independent censoring.\"\n#| warning: false\nsimulation_graph_rct1 \n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Update the theme to center the plot title\ntheme_update(plot.title = element_text(hjust = 0.5))\n\n\n# Convert sample size to a factor with levels sorted in decreasing order\nsimulation_rct2$sample.size <- factor(\n  simulation_rct2$sample.size, \n  levels = sort(unique(simulation_rct2$sample.size), decreasing = TRUE)\n)\n\n# Convert estimator column to a factor with the specified order\nsimulation_rct2$estimator <- factor(simulation_rct2$estimator, \n                                    levels = desired_order)\n\n# Create the plot for RCT + dependent censoring\nsimulation_graph_rct2 <- simulation_rct2 %>%\n  ggplot(aes(\n    x = estimator, y = estimate,  \n    fill = factor(sample.size, levels = rev(levels(sample.size)))\n  )) +\n  scale_fill_brewer(palette = \"Accent\") +\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +  # Change x-axis label\n  ylab(\"ATE\") +  # Change y-axis label\n  stat_boxplot(geom = \"errorbar\") +\n  geom_hline(\n    yintercept = truth_tau2, linetype = \"dashed\", color = \"red\", \n    alpha = 0.8, size = 0.8\n  ) +\n  theme(\n    legend.title = element_blank(), legend.position = \"bottom\",\n    legend.box = \"vertical\", legend.text = element_text(size = 18),\n    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  \n    # Adjust text angle for better visibility\n    axis.text = element_text(size = 15, face = \"bold\"),\n    axis.title.x = element_text(size = 16, face = \"bold\"),\n    plot.margin = margin(t = 10, r = 10, b = 50, l = 10)  # Add margin\n  ) + \n  coord_cartesian(ylim = c(0, 15))\n```\n\n```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}\n#| label: fig-rct2\n#| fig-cap: \"Estimation results of the ATE for the simulation of a RCT with dependent censoring.\"\n#| warning: false\nsimulation_graph_rct2\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Obs1:  Treatment assignment dependent on X + independent censoring\n# Obs2:  Treatment assignment dependent on X + dependent censoring (conditional \n# on X)\n\n# Function to simulate observational data for two scenarios: Obs1 and Obs2\nsimulate_data_obs <- function(n, \n                              mu = c(1, 1, -1, 1), \n                              sigma = diag(4), \n                              colnames_cov = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n                              tau,\n                              coefT0 = 0.01, \n                              parsS = c(0.5, 0.5, -0.5, 0.5),\n                              parsA = c(-1, -1, -2.5, -1), \n                              parsC_A = c(0), \n                              coefC = 0.03,\n                              parsC = c(0.7, 0.3, -0.25, -0.1), \n                              scenario = \"Obs2\") {\n  \n  # Generate covariates X from a multivariate normal distribution\n  X <- mvrnorm(n, mu, sigma)\n  X <- as.data.frame(X)\n  colnames(X) <- colnames_cov\n  \n  # Propensity score model based on X\n  e <- rowSums(as.matrix(X) %*% diag(parsA))\n  e <- plogis(e)  # Transform to probability scale\n  \n  # Treatment assignment based on the propensity score\n  A <- sapply(e, FUN = function(p) rbinom(n = 1, size = 1, prob = p))\n  \n  # Outcome model based on X\n  X_outcome <- as.matrix(X)\n  epsilon <- runif(n, min = 0.00000001, max = 1)\n  T0 <- -log(epsilon) / (coefT0 * exp(X_outcome %*% parsS))\n  \n  # Define treatment effect (shift in survival time due to treatment)\n  T1 <- T0 + 10\n  \n  if (scenario == \"Obs1\") {\n    # Scenario 1: Independent censoring\n    C <- -log(runif(n, min = 0.00000001, max = 1)) / coefC\n    \n  } else if (scenario == \"Obs2\") {\n    # Scenario 2: Dependent censoring based on X\n    X_censoring <- as.matrix(cbind(X,A))\n    parsC <- c(parsC,parsC_A)\n    \n    C <- -log(runif(n, min = 0.00000001, max = 1)) / \n      (coefC * exp(rowSums(X_censoring %*% diag(parsC))))\n    \n  } else {\n    stop(\"Invalid scenario. Choose 'Obs1' or 'Obs2'.\")\n  }\n  \n  # Determine the true survival time based on treatment\n  T_true <- A * T1 + (1 - A) * T0\n  \n  # Observed time is the minimum of the true survival time and censoring time\n  T_obs <- pmin(T_true, C)\n  \n  # Status indicator: 1 if the event (death) occurred, 0 if censored\n  status <- as.numeric(T_true <= C)\n  \n  # Restricted survival time (censored at tau)\n  T_obs_tau <- pmin(T_obs, tau)\n  status_tau <- as.numeric((T_obs > tau) | (T_obs <= tau & status == 1))\n  \n  # Compile the simulated data into a data frame\n  DATA_target_population <- data.frame(X, tau, A, T0, T1, C, T_obs, T_obs_tau, \n                                       status, status_tau, e)\n  \n  return(DATA_target_population)\n}\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Observational data with no informative censoring\ndata_obs1 <- simulate_data_obs(n = 2000, tau = 25, scenario = \"Obs1\")\n\n# Observational data simulation with dependent censoring\ndata_obs2 <- simulate_data_obs(n = 2000, tau = 25, scenario = \"Obs2\", \n                               coefC = 0.03, parsC = c(0.7,0.3,-0.25,-0.1))\n\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Stratification by treatment \ngroup_0 <- data_obs1 %>%\n  dplyr:: filter(A == 0)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,T_tild=T_obs)\n\ngroup_1 <- data_obs1 %>%\n  dplyr:: filter(A == 1)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,T_tild=T_obs)\n\n# Summary statistics\nsummary_group_0 <- summary(group_0)\nsummary_group_1 <- summary(group_1)\n\nprint(paste(\"Descriptive statistics for group A=0:  \",nrow(group_0)))\nprint(summary_group_0)\n\nprint(paste(\"Descriptive statistics for group A=1:  \",nrow(group_1)))\nprint(summary_group_1)\n\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Stratification by treatment \ngroup_0 <- data_obs2 %>%\n  dplyr:: filter(A == 0)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,status_tau,T_obs,e)\n\ngroup_1 <- data_obs2 %>%\n  dplyr:: filter(A == 1)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,status_tau,T_obs,e)\n\n# Summary statistics\nsummary_group_0 <- summary(group_0)\nsummary_group_1 <- summary(group_1)\n\nprint(paste(\"Descriptive statistics for group A=0:  \",nrow(group_0)))\nprint(summary_group_0)\n\nprint(paste(\"Descriptive statistics for group A=1:  \",nrow(group_1)))\nprint(summary_group_1)\n\n```\n\n```{r}\n# Simulation for scenario Obs1\ndata_Obs1 <- simulate_data_obs(n = 100000, tau = 25, scenario = \"Obs1\")\n\n#plot_ground_truth(data_Obs1, \n#                  vec_tau, \n#                  tau, \n#                  c(0, 10),\n#                  \"True difference in RMST for Obs #scenario 1\")\n\ntruth_tau3 <-  ground_truth(data_Obs1, tau = 25)\nprint(paste0(\"The ground truth for Obs scenario 1 at time 25 is \", round(truth_tau3, 1)))\n\n# Simulation for scenario Obs2 with specific coefficients and parameters\ndata_Obs2 <- simulate_data_obs(\n  n = 100000, tau = tau, scenario = \"Obs2\", \n  coefC = 0.03, parsC = c(0.7, 0.3, -0.25, -0.1))\n\n#plot_ground_truth(data_Obs2, \n#                  vec_tau, \n#                  tau, \n#                  c(0, 10),\n#                  \"True difference in RMST for Obs #scenario 2\")\n\ntruth_tau4 <- ground_truth(data_Obs2, tau = 25)\nprint(paste0(\"The ground truth for Obs scenario 2 at #time 25 is \", round(truth_tau4, 1)))\n```\n\n```{r, eval=FALSE}\n# Obs1 simulation\nsimulation_obs1 <- compute_estimator(\n  n_sim, tau = tau, scenario = \"Obs1\", \n  X.names.propensity = c(\"X1\", \"X2\", \"X3\", \"X4\"), \n  X.names.outcome = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n  X.names.censoring = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n  nuisance_propensity = c(\"glm\", \"probability forest\"), \n  nuisance_censoring = c(\"cox\", \"survival forest\"), \n  nuisance_survival = c(\"cox\", \"survival forest\"), \n  n.folds_propensity = 5,\n  n.folds_censoring = 5,\n  n.folds_survival = 5,\n  coefC = 0.03\n)\nsave(simulation_obs1, file = \"simulation_obs1.RData\")\n\n\n# Obs2 simulation with specific coefficients and parameters\nsimulation_obs2 <- compute_estimator(\n  n_sim, tau = tau, scenario = \"Obs2\", \n  X.names.propensity = c(\"X1\", \"X2\", \"X3\", \"X4\"), \n  X.names.outcome = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n  X.names.censoring = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n  nuisance_propensity = c(\"glm\", \"probability forest\"), \n  nuisance_censoring = c(\"cox\", \"survival forest\"), \n  nuisance_survival = c(\"cox\", \"survival forest\"), \n  n.folds_propensity = 5,\n  n.folds_censoring = 5,\n  n.folds_survival = 5,\n  coefC = 0.03, \n  parsC = c(0.7, 0.3, -0.25, -0.1)\n)\nsave(simulation_obs2, file = \"simulation_obs2.RData\")\n```\n\n\n```{r}\nload(\"simulations/simulation_obs1.RData\")\nload(\"simulations/simulation_obs2.RData\")\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Update the theme to center the plot title\ntheme_update(plot.title = element_text(hjust = 0.5))\n\n# Convert sample size to a factor with levels sorted in decreasing order\nsimulation_obs1$sample.size <- factor(\n  simulation_obs1$sample.size, \n  levels = sort(unique(simulation_obs1$sample.size), decreasing = TRUE)\n)\n\n# Convert estimator column to a factor with the specified order\nsimulation_obs1$estimator <- factor(simulation_obs1$estimator, \n                                    levels = desired_order)\n\n# Create the plot for Observational + independent censoring\nsimulation_graph_obs1 <- simulation_obs1 %>%\n  ggplot(aes(\n    x = estimator, y = estimate,  \n    fill = factor(sample.size, levels = rev(levels(sample.size)))\n  )) +\n  scale_fill_brewer(palette = \"Accent\") +\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +  # Change x-axis label\n  ylab(\"ATE\") +  # Change y-axis label\n  stat_boxplot(geom = \"errorbar\") +\n  geom_hline(\n    yintercept = truth_tau3, linetype = \"dashed\", color = \"red\", \n    alpha = 0.8, size = 0.8\n  ) +\n  theme(\n    legend.title = element_blank(), legend.position = \"bottom\",\n    legend.box = \"vertical\", legend.text = element_text(size = 18),\n    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  \n    # Adjust text angle for better visibility\n    axis.text = element_text(size = 15, face = \"bold\"),\n    axis.title.x = element_text(size = 16, face = \"bold\"),\n    plot.margin = margin(t = 10, r = 10, b = 50, l = 10)  # Add margin\n  ) + \n  coord_cartesian(ylim = c(0, 15))\n\n```\n\n```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}\n#| label: fig-obs1\n#| fig-cap: \"Estimation results of the ATE for the simulation of an observational study with independent censoring.\"\n#| warning: false\nsimulation_graph_obs1\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Update the theme to center the plot title\ntheme_update(plot.title = element_text(hjust = 0.5))\n\n# Convert sample size to a factor with levels sorted in decreasing order\nsimulation_obs2$sample.size <- factor(\n  simulation_obs2$sample.size, \n  levels = sort(unique(simulation_obs2$sample.size), decreasing = TRUE)\n)\n\n# Convert estimator column to a factor with the specified order\nsimulation_obs2$estimator <- factor(simulation_obs2$estimator, \n                                    levels = desired_order)\n\n# Create the plot for Observational + dependent censoring\nsimulation_graph_obs2 <- simulation_obs2 %>%\n  ggplot(aes(\n    x = estimator, y = estimate,  \n    fill = factor(sample.size, levels = rev(levels(sample.size)))\n  )) +\n  scale_fill_brewer(palette = \"Accent\") +\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +  # Change x-axis label\n  ylab(\"ATE\") +  # Change y-axis label\n  stat_boxplot(geom = \"errorbar\") +\n  geom_hline(\n    yintercept = truth_tau4, linetype = \"dashed\", color = \"red\", \n    alpha = 0.8, size = 0.8\n  ) +\n  theme(\n    legend.title = element_blank(), legend.position = \"bottom\",\n    legend.box = \"vertical\", legend.text = element_text(size = 18),\n    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  \n    # Adjust text angle for better visibility\n    axis.text = element_text(size = 15, face = \"bold\"),\n    axis.title.x = element_text(size = 16, face = \"bold\"),\n    plot.margin = margin(t = 10, r = 10, b = 50, l = 10)  # Add margin\n  ) + \n  coord_cartesian(ylim = c(0, 15))\n\n```\n\n```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}\n#| label: fig-obs2\n#| fig-cap: \"Estimation results of the ATE for the simulation of an observational study with dependent censoring.\"\n#| warning: false\nsimulation_graph_obs2\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# DGP for misspecification \nsimulate_data_mis <- function(n, \n                              mu = c(0.5, 0.5, 0.7, 0.5),\n                              sigma =  matrix(c(1, 0, 0, 0, \n                                                0, 1, 0, 0, \n                                                0, 0, 1, 0,\n                                                0, 0, 0, 1), \n                                              nrow = 4, byrow = TRUE),\n                              colnames_cov = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n                              parsA =  c(0.05, -0.1, 0.5, -0.1),\n                              tau){\n  \n  # Generate X from a multivariate normal distribution\n  X <- MASS::mvrnorm(n, mu, sigma)\n  X <- as.data.frame(X)\n  colnames(X) <- colnames_cov\n  \n  # Treatment variable selection: all X\n  X_treatment <- as.matrix(X)\n  \n  # Propensity score model based on X\n  e <- parsA[1]*X_treatment[, \"X1\"]^2 + parsA[2]*X_treatment[, \"X2\"]^2 + \n    parsA[3]*X_treatment[, \"X3\"]^2 + parsA[4]*X_treatment[, \"X4\"]^2-\n    X_treatment[, \"X1\"]*X_treatment[, \"X2\"] +\n    X_treatment[, \"X1\"]*X_treatment[, \"X4\"]\n  \n  # Logistic regression\n  e <- plogis(e)\n  \n  # Treatment assignment based on the propensity score\n  A <- sapply(e, FUN = function(p) rbinom(n = 1, size = 1, prob = p))\n  \n  # Outcome variable selection: all X\n  X_outcome <- as.matrix(X)\n  \n  lambda <- exp(0.2*X[,1]^2 + 0.3*X[,2]^2 + 0.1*X[,3]^2 + 0.1*X[,4]^2 + \n    X[,1] * X[,2] + X[,3] * X[,4])\n  # Simulate the outcome using the cumulative hazard inversion method\n  epsilon <- runif(n, min = 1e-8, max = 1)\n  T0 <- -log(epsilon) / lambda\n  \n  # Simulate independent censoring time\n  censoring_lambda <- exp(0.05*X[,1]^2 + 0.05*X[,2]^2-0.1*X[,3]^2 + 0.1*X[,4]^2 + \n    X[,3] * X[,1] - X[,2]*X[,4])\n  epsilon <- runif(n, min = 1e-8, max = 1)\n  C <- -log(epsilon) / censoring_lambda\n  \n  \n  # T(1) = T(0) + 1\n  T1 <- T0 + 1\n  \n  # True survival time\n  T_true <- A * T1 + (1 - A) * T0\n  \n  # Observed time\n  T_obs <- pmin(T_true, C)\n  \n  # Status indicator\n  status <- as.numeric(T_true <= C)\n  censor.status <- as.numeric(T_true > C)\n  \n  # Restricted survival time\n  T_obs_tau <- pmin(T_obs, tau)\n  status_tau <- as.numeric((T_obs > tau) | (T_obs <= tau & status == 1))\n  # Compile the simulated data into a data frame\n  DATA_target_population <- data.frame(X, tau, A, T0, T1, C, T_obs, T_obs_tau, \n                                       status, status_tau, censor.status, e)\n  \n  return(DATA_target_population)\n}\n\n\n```\n\n```{r}\n# Function to estimate RMST for each misspecification context\ncompute_estimator_mispec <- function(n_sim, tau, \n                                     X.names.propensity_mis, \n                                     X.names.propensity, \n                                     X.names.outcome,\n                                     X.names.outcome_mis,\n                                     X.names.censoring,\n                                     X.names.censoring_mis,\n                                     nuisance_propensity = \"glm\", \n                                     nuisance_censoring = \"cox\", \n                                     nuisance_survival = \"cox\", \n                                     n.folds_propensity = NULL,\n                                     n.folds_censoring = NULL, \n                                     n.folds_survival = NULL,\n                                     estimator = \"all\",\n                                     sample_sizes = c(8000)) {\n  \n  pb_n <- txtProgressBar(min = 0, max = length(sample_sizes) * n_sim, \n                         style = 3, initial = 0, char = \"#\")\n  on.exit(close(pb_n))\n  \n  # Initialize data frame for each misspecification\n  simulation_mis <- data.frame()\n  simulation_mistreat <- data.frame()\n  simulation_misout <- data.frame()\n  simulation_miscens <- data.frame()\n  simulation_mistreat_out <- data.frame()\n  simulation_miscens_out <- data.frame()\n  simulation_mistreat_cens <- data.frame()\n  simulation_misall <- data.frame()\n\n  # Function to compute estimators for multiple simulations and sample sizes\n  for (n in sample_sizes) {\n    for (i in 1:n_sim) {\n      setTxtProgressBar(pb_n, (which(sample_sizes == n) - 1) * n_sim + i)\n      data <- simulate_data_mis(n, tau = tau)\n\n      # Compute all estimates for the simulated data\n      res_all_mis <- all_estimates(data, n, tau = tau, \n                                   X.names.propensity = X.names.propensity, \n                                   X.names.outcome = X.names.outcome,\n                                   X.names.censoring = X.names.censoring,\n                                   nuisance_propensity = nuisance_propensity, \n                                   nuisance_censoring = nuisance_censoring,\n                                   nuisance_survival = nuisance_survival, \n                                   n.folds_propensity = n.folds_propensity, \n                                   n.folds_censoring = n.folds_censoring, \n                                   n.folds_survival = n.folds_survival,\n                                   estimator)\n      \n      res_all_mistreat <- all_estimates(data, n, tau = tau, \n                                        X.names.propensity = X.names.propensity_mis, \n                                        X.names.outcome = X.names.outcome,\n                                        X.names.censoring = X.names.censoring,\n                                        nuisance_propensity = nuisance_propensity,\n                                        nuisance_censoring = nuisance_censoring,\n                                        nuisance_survival = nuisance_survival,  \n                                        n.folds_propensity = n.folds_propensity, \n                                        n.folds_censoring = n.folds_censoring, \n                                        n.folds_survival = n.folds_survival,\n                                        estimator)\n      \n      res_all_misout <- all_estimates(data, n, tau = tau, \n                                      X.names.propensity = X.names.propensity, \n                                      X.names.outcome = X.names.outcome_mis,\n                                      X.names.censoring = X.names.censoring,\n                                      nuisance_propensity = nuisance_propensity,\n                                      nuisance_censoring = nuisance_censoring,\n                                      nuisance_survival = nuisance_survival,  \n                                      n.folds_propensity = n.folds_propensity, \n                                      n.folds_censoring = n.folds_censoring, \n                                      n.folds_survival = n.folds_survival,\n                                      estimator)\n      \n      res_all_miscens <- all_estimates(data, n, tau = tau, \n                                       X.names.propensity = X.names.propensity, \n                                       X.names.outcome = X.names.outcome,\n                                       X.names.censoring = X.names.censoring_mis,\n                                       nuisance_propensity = nuisance_propensity,\n                                       nuisance_censoring = nuisance_censoring,\n                                       nuisance_survival = nuisance_survival,  \n                                       n.folds_propensity = n.folds_propensity, \n                                       n.folds_censoring = n.folds_censoring, \n                                       n.folds_survival = n.folds_survival,\n                                       estimator)\n      \n      res_all_mistreat_out <- all_estimates(data, n, tau = tau, \n                                            X.names.propensity = X.names.propensity_mis, \n                                            X.names.outcome = X.names.outcome_mis,\n                                            X.names.censoring = X.names.censoring,\n                                            nuisance_propensity = nuisance_propensity,\n                                            nuisance_censoring = nuisance_censoring,\n                                            nuisance_survival = nuisance_survival,\n                                            n.folds_propensity = n.folds_propensity, \n                                            n.folds_censoring = n.folds_censoring, \n                                            n.folds_survival = n.folds_survival,\n                                            estimator)\n      \n      res_all_miscens_out <- all_estimates(data, n, tau = tau, \n                                           X.names.propensity = X.names.propensity, \n                                           X.names.outcome = X.names.outcome_mis,\n                                           X.names.censoring = X.names.censoring_mis,\n                                           nuisance_propensity = nuisance_propensity,\n                                           nuisance_censoring = nuisance_censoring,\n                                           nuisance_survival = nuisance_survival,\n                                           n.folds_propensity = n.folds_propensity, \n                                           n.folds_censoring = n.folds_censoring, \n                                           n.folds_survival = n.folds_survival,\n                                           estimator)\n      \n      res_all_mistreat_cens <- all_estimates(data, n, tau = tau, \n                                             X.names.propensity = X.names.propensity_mis, \n                                             X.names.outcome = X.names.outcome,\n                                             X.names.censoring = X.names.censoring_mis,\n                                             nuisance_propensity = nuisance_propensity,\n                                             nuisance_censoring = nuisance_censoring,\n                                             nuisance_survival = nuisance_survival,\n                                             n.folds_propensity = n.folds_propensity, \n                                             n.folds_censoring = n.folds_censoring, \n                                             n.folds_survival = n.folds_survival,\n                                             estimator)\n      \n      res_all_misall <- all_estimates(data, n, tau = tau, \n                                      X.names.propensity = X.names.propensity_mis, \n                                      X.names.outcome = X.names.outcome_mis,\n                                      X.names.censoring = X.names.censoring_mis,\n                                      nuisance_propensity = nuisance_propensity,\n                                      nuisance_censoring = nuisance_censoring,\n                                      nuisance_survival = nuisance_survival,\n                                      n.folds_propensity = n.folds_propensity, \n                                      n.folds_censoring = n.folds_censoring, \n                                      n.folds_survival = n.folds_survival,\n                                      estimator)\n      \n      # Store the results\n      simulation_mis <- rbind(simulation_mis, res_all_mis)\n      simulation_mistreat <- rbind(simulation_mistreat, res_all_mistreat)\n      simulation_misout <- rbind(simulation_misout, res_all_misout)\n      simulation_miscens <- rbind(simulation_miscens, res_all_miscens)\n      simulation_mistreat_out <- rbind(simulation_mistreat_out, res_all_mistreat_out)\n      simulation_miscens_out <- rbind(simulation_miscens_out, res_all_miscens_out)\n      simulation_mistreat_cens <- rbind(simulation_mistreat_cens, res_all_mistreat_cens)\n      simulation_misall <- rbind(simulation_misall, res_all_misall)\n    }\n  }\n  \n  # Fusion of dataframe\n  return(list(\n    simulation_mis = simulation_mis,\n    simulation_mistreat = simulation_mistreat,\n    simulation_misout = simulation_misout,\n    simulation_miscens = simulation_miscens,\n    simulation_mistreat_out = simulation_mistreat_out,\n    simulation_miscens_out = simulation_miscens_out,\n    simulation_mistreat_cens = simulation_mistreat_cens,\n    simulation_misall = simulation_misall\n  ))\n}\n```\n\n\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nmis <- simulate_data_mis(n=2000,tau=0.5)\nsummary(mis)\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Stratification by treatment \ngroup_0 <- mis %>%\n  dplyr:: filter(A == 0)%>%\n  dplyr:: select(X1,X2,X3,C,T1,T0,status,T_obs,status_tau,e)\n\ngroup_1 <- mis %>%\n  dplyr:: filter(A == 1)%>%\n  dplyr:: select(X1,X2,X3,C,T1,T0,status,T_obs,status_tau,e)\n\n# Summary statistics\nsummary_group_0 <- summary(group_0)\nsummary_group_1 <- summary(group_1)\n\nprint(paste(\"Descriptive statistics for group A=0:  \",nrow(group_0)))\nprint(summary_group_0)\n\nprint(paste(\"Descriptive statistics for group A=1:  \",nrow(group_1)))\nprint(summary_group_1)\n\n```\n\n```{r}\n# Mis scenario \ntau_mis <- 0.5\nvec_tau_complex <- seq(0, 10, by = 0.05)\ndata_mis <- simulate_data_mis(n = 150000, tau = tau_mis)\n\n#plot_ground_truth(data_mis,\n#                  vec_tau_complex, \n#                  tau_mis, \n#                  c(0, 1), \n#                  \"True difference in RMST for Mis scenario\")\n\ntruth_complex_mis <- ground_truth(data_mis, tau = tau_mis)\n\nprint(paste0(\"The ground truth for mis scenario at time 0.45 is \", round(truth_complex_mis,2)))\n```\n\n\n```{r eval=FALSE}\nn_sim <- 100\ntau <- 0.5\nsimulation_mis <- compute_estimator(\n  n_sim, tau = tau, scenario = \"Mis\", \n  X.names.propensity = c(\"I(X1^2)\", \"I(X2^2)\",\"I(X3^2)\", \"I(X4^2)\", \n                         \"X1*X2\",\"X1*X4\"),\n  X.names.outcome = c(\"I(X1^2)\", \"I(X2^2)\",\"I(X3^2)\", \"I(X4^2)\", \n                      \"X1:X2\", \"X3:X4\"),\n  X.names.censoring = c(\"I(X1^2)\", \"I(X2^2)\",\"I(X3^2)\", \"I(X4^2)\", \n                        \"X1:X3\", \"X2:X4\"),\n  nuisance_propensity = c(\"glm\"), \n  nuisance_censoring = c(\"cox\"), \n  nuisance_survival = c(\"cox\"), \n  n.folds_propensity = NULL,\n  n.folds_censoring = NULL,\n  n.folds_survival = NULL,\n  sample_sizes = c(500, 1000, 2000, 4000, 8000),\n  estimator = c(\"Naive\", \"KM\", \"IPTW KM\", \"IPCW KM\", \"BJ\", \n                \"IPTW-IPCW KM\", \"IPTW-BJ\", \"G_formula (T-learners)\", \n                \"G_formula (S-learner)\", \"AIPTW-AIPCW\")\n)\nsave(simulation_mis, file=\"simulation_mis.RData\") \n\nsimulation_mis_c <- compute_estimator(\n  n_sim, tau = tau, scenario = \"Mis\", \n  X.names.propensity = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n  X.names.outcome = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n  X.names.censoring = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n  nuisance_propensity = c(\"probability forest\"), \n  nuisance_censoring = c(\"survival forest\"), \n  nuisance_survival = c(\"survival forest\"), \n  n.folds_propensity = 5,\n  n.folds_censoring = 5,\n  n.folds_survival = 5,\n  sample_sizes = c(500, 1000, 2000, 4000, 8000),\n  estimator = c(\"IPTW KM\", \"IPCW KM\", \"BJ\", \n                \"IPTW-IPCW KM\", \"IPTW-BJ\", \"G_formula (T-learners)\", \n                \"G_formula (S-learner)\", \"AIPTW-AIPCW\",\n                \"grf - Causal Survival Forest\")\n)\n\nsave(simulation_mis_c, file=\"simulation_mis_c.RData\") \n\nsimulation_mis_c_16000 <- compute_estimator(\n  n_sim, tau = tau, scenario = \"Mis\", \n  X.names.propensity = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n  X.names.outcome = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n  X.names.censoring = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n  nuisance_propensity = c(\"probability forest\"), \n  nuisance_censoring = c(\"survival forest\"), \n  nuisance_survival = c(\"survival forest\"), \n  n.folds_propensity = 5,\n  n.folds_censoring = 5,\n  n.folds_survival = 5,\n  sample_sizes = 16000,\n  estimator = c(\"IPTW KM\", \"G_formula (T-learners)\")\n)\nsave(simulation_mis_c_16000, file=\"simulation_mis_c_16000.RData\")  \n```\n\n\n```{r}\nload(\"simulations/simulation_mis.RData\")\nload(\"simulations/simulation_mis_c.RData\")\nload(\"simulations/simulation_mis_c_16000.RData\")\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Define the desired order of the estimators\nsimulation_mis2 <- rbind(simulation_mis,simulation_mis_c)\nsimulation_mis2 <- rbind(simulation_mis2,simulation_mis_c_16000)\n\ndesired_order <- c(\n  \"Naive\",\n  \"KM\",\n  \"SurvRM2 - KM\",\n  \"IPTW KM (Log. Reg.)\",\n  \"IPCW KM (Cox)\",\n  \"BJ (Cox)\",\n  \"IPTW-BJ (Cox & Log. Reg.)\",\n  \"IPTW-IPCW KM (Cox & Log. Reg.)\",\n  \"G-formula (Cox/ T-learners)\",\n  \"G-formula (Cox/ S-learner)\",\n  \"AIPTW-AIPCW (Cox & Cox & Log. Reg.)\",\n  \"grf - Causal Survival Forest\",\n  \"IPTW KM (Forest)\",\n  \"IPCW KM (Forest)\",\n  \"BJ (Forest)\",\n  \"IPTW-BJ (Forest)\",\n  \"IPTW-IPCW KM (Forest)\",\n  \"G-formula (Forest/ T-learners)\",\n  \"G-formula (Forest/ S-learner)\",\n  \"AIPTW-AIPCW (Forest)\")\n\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_mis2$sample.size <- factor(simulation_mis2$sample.size, \n                                      levels = sort(unique(simulation_mis2$sample.size), \n                                                    decreasing = TRUE))\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_mis2$estimator <- factor(simulation_mis2$estimator, levels = desired_order)\n\nsimulation_graph_mis <- simulation_mis2 %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, \n                                                         levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"No misspecification:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +  # Changer le label de l'axe x\n  ylab(\"ATE\") +  # Retirer le label de l'axe y\n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Changer geom_hline en geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(size = 15, angle = 45, vjust = 1, hjust = 1),\n          axis.text.y = element_text(size = 15),\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n\n```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}\n#| label: fig-mis3\n#| fig-cap: \"Estimation results of the ATE for the simulation of an observational study with dependent censoring and non linear relationships.\"\n#| warning: false\nsimulation_graph_mis\n```\n\n\n```{r eval=FALSE}\nn_sim <- 100\ntau <- 0.5\nmis <- compute_estimator_mispec(n_sim, tau = tau, \n                                   X.names.propensity = c(\"I(X1^2)\", \"I(X2^2)\",\n                                                          \"I(X3^2)\", \"I(X4^2)\", \n                                                          \"X1*X2\",\"X1*X4\"),\n                                   X.names.outcome = c(\"I(X1^2)\", \"I(X2^2)\",\n                                                       \"I(X3^2)\", \"I(X4^2)\", \n                                                       \"X1:X2\", \"X3:X4\"),\n                                   X.names.censoring = c(\"I(X1^2)\", \"I(X2^2)\",\n                                                         \"I(X3^2)\", \"I(X4^2)\", \n                                                         \"X1:X3\", \"X2:X4\"),\n                                   X.names.propensity_mis = c(\"I(X1^2)\",\"I(X2^2)\",\n                                                              \"I(X3^2)\", \"I(X4^2)\"),\n                                   X.names.outcome_mis = c(\"I(X1^2)\", \"I(X2^2)\",\n                                                           \"I(X3^2)\", \"I(X4^2)\"),\n                                   X.names.censoring_mis = c(\"I(X1^2)\", \"I(X2^2)\",\n                                                             \"I(X3^2)\", \"I(X4^2)\"),\n                                   nuisance_propensity = c(\"glm\"), \n                                   nuisance_censoring = c(\"cox\"), \n                                   nuisance_survival = c(\"cox\"),\n                                   estimator = estimators,\n                                   sample_size = 8000)\n\n\n# Initialize a list to decompose the results\nmerged_results <- list()\n\n# All the defined sceanario\nscenarios <- c(\"simulation_mis\", \"simulation_mistreat\", \"simulation_misout\",\n               \"simulation_miscens\", \"simulation_mistreat_out\", \n               \"simulation_miscens_out\", \"simulation_mistreat_cens\", \n               \"simulation_misall\")\n\n# Loop through all scenarios\nfor (s in scenarios) {\n  # Initialize an empty dataframe\n  scenario_results <- data.frame()\n  \n  # Loop through all sample sizes\n  for (i in seq_along(sample_sizes)) {\n    # Append the results for the given scenario and sample size \n    scenario_results <- rbind(scenario_results, results[[i]][[s]])\n  }\n  \n  # Add the results for the given scenario to the results list \n  merged_results[[s]] <- scenario_results\n  \n  # Save the final results for the given scenario in an .RData file\n  assign(paste0(s), scenario_results)\n  save(list = paste0(s), file = sprintf(\"%s.RData\", s))\n}\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nload(\"simulations/simulation_mis2.RData\")\nload(\"simulations/simulation_mistreat.RData\")\nload(\"simulations/simulation_miscens.RData\")\nload(\"simulations/simulation_misout.RData\")\n\n# Define the desired order of the estimators\ndesired_order_mis <- c(\n  \"Naive\", \"KM\",\n\"IPTW KM (Log. Reg.)\",\n  \"IPCW KM (Cox)\", \"BJ (Cox)\",  \"IPTW-BJ (Cox & Log. Reg.)\", \n\"IPTW-IPCW KM (Cox & Log. Reg.)\",\n  \"G-formula (Cox/ T-learners)\", \"G-formula (Cox/ S-learner)\",\n  \"AIPTW-AIPCW (Cox & Cox & Log. Reg.)\"\n)\n\nsimulation_mis2 <- simulation_mis2[simulation_mis2$estimator %in% desired_order_mis, ]\n\n\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_mis2$sample.size <- factor(simulation_mis2$sample.size, \n                                      levels = sort(unique(simulation_mis2$sample.size), \n                                                    decreasing = TRUE))\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_mis2$estimator <- factor(simulation_mis2$estimator, levels = desired_order)\n\nsimulation_graph_mis2 <- simulation_mis2 %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, \n                                                         levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"No misspecification:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +\n  ylab(\"ATE\") + \n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Change geom_hline to geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_mistreat$sample.size <- factor(simulation_mistreat$sample.size, levels = sort(unique(simulation_mistreat$sample.size), decreasing = TRUE))\n\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_mistreat$estimator <- factor(simulation_mistreat$estimator, levels = desired_order_mis)\n\nsimulation_graph_mis_mistreat <- simulation_mistreat %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"Misspecification of treatment model:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +  \n  ylab(\"ATE\") + \n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Changer geom_hline en geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_miscens$sample.size <- factor(simulation_miscens$sample.size, levels = sort(unique(simulation_miscens$sample.size), decreasing = TRUE))\n\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_miscens$estimator <- factor(simulation_miscens$estimator, levels = desired_order_mis)\n\nsimulation_graph_mis_miscens <- simulation_miscens %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"Misspecification of censoring model:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +\n  ylab(\"ATE\") +\n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Change geom_hline to geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_misout$sample.size <- factor(simulation_misout$sample.size, levels = sort(unique(simulation_misout$sample.size), decreasing = TRUE))\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_misout$estimator <- factor(simulation_misout$estimator, levels = desired_order_mis)\n\nsimulation_graph_mis_misout <- simulation_misout %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"Misspecification of outcome model:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") + \n  ylab(\"ATE\") + \n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Changer geom_hline to geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n\n```{r fig.width=25, fig.height=25, message=FALSE, warning=FALSE}\n#| label: fig-mis\n#| fig-cap: \"Estimation results of the ATE for an observational study with dependent censoring in case of a single misspecification.\"\n#| warning: false\ngrid.arrange(simulation_graph_mis2, simulation_graph_mis_miscens, simulation_graph_mis_misout, simulation_graph_mis_mistreat, ncol = 2, nrow = 2)\n```\n\n```{r}\nload(\"simulations/simulation_mistreat_out.RData\")\nload(\"simulations/simulation_miscens_out.RData\")\nload(\"simulations/simulation_mistreat_cens.RData\")\nload(\"simulations/simulation_misall.RData\")\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_mistreat_out$sample.size <- factor(simulation_mistreat_out$sample.size, levels = sort(unique(simulation_mistreat_out$sample.size), decreasing = TRUE))\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_mistreat_out$estimator <- factor(simulation_mistreat_out$estimator, levels = desired_order_mis)\n\nsimulation_graph_mis_mistreat_out <- simulation_mistreat_out %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"Misspecification of outcome and treatment model:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") + \n  ylab(\"ATE\") +\n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Change geom_hline to geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_miscens_out$sample.size <- factor(simulation_miscens_out$sample.size, levels = sort(unique(simulation_miscens_out$sample.size), decreasing = TRUE))\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_miscens_out$estimator <- factor(simulation_miscens_out$estimator, levels = desired_order_mis)\n#simulation_mis$estimator[is.na(simulation_mis$estimator)] <- \"G_formula (S-learner)\"\n\nsimulation_graph_mis_miscens_out <- simulation_miscens_out %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"Misspecification of censoring and outcome model:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +  \n  ylab(\"ATE\") + \n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Change geom_hline to geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_mistreat_cens$sample.size <- factor(simulation_mistreat_cens$sample.size, levels = sort(unique(simulation_mistreat_cens$sample.size), decreasing = TRUE))\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_mistreat_cens$estimator <- factor(simulation_mistreat_cens$estimator, levels = desired_order_mis)\n#simulation_mis$estimator[is.na(simulation_mis$estimator)] <- \"G_formula (S-learner)\"\n\nsimulation_graph_mis_mistreat_cens <- simulation_mistreat_cens %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"Misspecification of censoring and treatment model:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") + \n  ylab(\"ATE\") + \n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Change geom_hline to geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_misall$sample.size <- factor(simulation_misall$sample.size, levels = sort(unique(simulation_misall$sample.size), decreasing = TRUE))\n\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_misall$estimator <- factor(simulation_misall$estimator, levels = desired_order_mis)\n#simulation_mis$estimator[is.na(simulation_mis$estimator)] <- \"G_formula (S-learner)\"\n\nsimulation_graph_mis_all <- simulation_misall %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"Misspecification of all models:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") + \n  ylab(\"ATE\") + \n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Change geom_hline to geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n```{r fig.width=25, fig.height=25, message=FALSE, warning=FALSE}\n#| label: fig-mis2\n#| fig-cap: \"Estimation results of the ATE for an observational study with dependent censoring in case of a two or more misspecifications.\"\n#| warning: false\ngrid.arrange(simulation_graph_mis_mistreat_out, simulation_graph_mis_miscens_out, simulation_graph_mis_mistreat_cens, simulation_graph_mis_all, ncol = 2, nrow = 2)\n```\n\n","srcMarkdownNoYaml":"\n\n\n# Estimators \n\n\n**Unadjusted Kaplan-Meier** \n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nsource(\"utilitary.R\")\n# Kaplan-Meier estimator handmade implementation\n# The database 'data' must be in the same form as that shown in \n# notation (Table 1) and with the same variable names (status, T_obs) \nKaplan_meier_handmade <- function(data, \n                                  status = data$status, \n                                  T_obs = data$T_obs) {\n  # Sort unique observed times\n  Y.grid <- sort(unique(T_obs))\n  \n  # Initialize vectors for number of events, number at risk, and survival \n  # probability\n  d <- rep(NA, length(Y.grid))  # Number of events at time Y.grid[i]\n  n <- rep(NA, length(Y.grid))  # Number at risk just before time Y.grid[i]\n  S <- rep(NA, length(Y.grid))  # Survival probability at time Y.grid[i]\n  \n  # Loop over each unique observed time\n  for (i in 1:length(Y.grid)) {\n    d[i] <- sum(T_obs == Y.grid[i] & status == 1, na.rm = TRUE)  # Count events\n    n[i] <- sum(T_obs >= Y.grid[i])  # Count at risk\n    \n    # Calculate survival probability\n    S[i] <- cumprod(1 - d / n)[i]\n  }\n  \n  # Create a dataframe with the results\n  df <- data.frame(d = d, n = n, S = S, T = Y.grid)\n  \n  return(df)\n}\n\n\n# Function to calculate RMST (Restricted Mean Survival Time):\n# Two possibilities for computing RMST: \n# - in using directly S_A1 and S_A0 (survival function of treated and control)\n# - in using the dataframe and the function computes the survival functions\nRMST_1 <- function(data = NULL, A1 = 1, A0 = 0, tau, S_A1 = NULL, S_A0 = NULL) {\n  if (is.null(S_A1) & is.null(S_A0)) {\n    # Subset data for treatment groups\n    data1 <- data[data$A == A1,]\n    data0 <- data[data$A == A0,]\n    \n    # Calculate Kaplan-Meier survival estimates\n    S_A1 <- Kaplan_meier_handmade(data1, status = data1$status, \n                                  T_obs = data1$T_obs)\n    S_A0 <- Kaplan_meier_handmade(data0, status = data0$status, \n                                  T_obs = data0$T_obs)\n    \n    # Restrict observations to those less than or equal to tau\n    Y.grid1 <- data1$T_obs[data1$T_obs <= tau]\n    Y.grid0 <- data0$T_obs[data0$T_obs <= tau]\n  } else {\n    # Restrict observations to those less than or equal to tau\n    Y.grid1 <- S_A1$T[S_A1$T <= tau]\n    Y.grid0 <- S_A0$T[S_A0$T <= tau]\n  }\n  \n  # Filter survival estimates to restricted observations\n  S_A1 <- S_A1 %>%\n    dplyr::filter(T %in% Y.grid1)\n  S_A0 <- S_A0 %>%\n    dplyr::filter(T %in% Y.grid0)\n  \n  # Check if there is any event at tau for S_A1\n  if (!any(S_A1$T == tau)) {\n    new_row <- tibble(T = tau, S = S_A1$S[nrow(S_A1)])\n    S_A1 <- dplyr::bind_rows(S_A1, new_row)\n  }\n  \n  # Check if there is any event at tau for S_A0\n  if (!any(S_A0$T == tau)) {\n    new_row <- tibble(T = tau, S = S_A0$S[nrow(S_A0)])\n    S_A0 <- dplyr::bind_rows(S_A0, new_row)\n  }\n\n  # Calculate integrals from 0 to tau of survival probabilities\n  intA1 <- integral_rectangles(S_A1$T, S_A1$S)\n  intA0 <- integral_rectangles(S_A0$T, S_A0$S)\n  RMST1 <- intA1 - intA0\n  \n  return(list(RMST=RMST1, intA1=intA1,intA0=intA0))\n}\n\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Alternative code to estimate Kaplan-Meier estimator with survival package\n# instead of handmade KM\nRMST_alternative <- function(data, A1 = 1, A0 = 0, tau){\n  # Estimate Kaplan-Meier estimator with survfit function on data subset\n   # Groupe A = 0\n  fit0 <- survfit(Surv(T_obs, status) ~ 1, data = data[data$A == A0,]) \n  # Groupe A = 1\n  fit1 <- survfit(Surv(T_obs, status) ~ 1, data = data[data$A == A1,])  \n\n  # Estimate the RMST with rmean\n  summary_fit0 <- summary(fit0, rmean = tau)  # RMST for A = 0\n  summary_fit1 <- summary(fit1, rmean = tau)  # RMST for A = 1\n\n  # Extract the RMST from the summary objects\n  rmst0 <- summary_fit0$table[\"rmean\"][[1]]\n  rmst1 <- summary_fit1$table[\"rmean\"][[1]]\n\n  # Compute the difference of RMST between the two groups\n  difference_rmst <- rmst1 - rmst0\nreturn(difference_rmst)\n}\n```\n\n\n**IPCW Kaplan-Meier**\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Kaplan-Meier adjusted\n# Times of event \n# Failures:  1 if event, 0 if censored\n# Variable:  1 if treated, 0 if control\n# Weights:  Weight of the individual\nadjusted.KM <- function(times, failures, variable, weights = NULL) {\n  # Sanity checks\n  if (sum(times < 0) > 0) {\n    stop(\"Error: times must be positive\")\n  }\n  if (!is.null(weights) && sum(weights < 0, na.rm = TRUE) > 0) {\n    stop(\"Error: weights must be superior to 0\")\n  }\n  if (sum(failures != 0 & failures != 1) > 0) {\n    stop(\"Error: failures must be a vector of 0 or 1\")\n  }\n  # If 'weights' is NULL, initialize 'w' with ones of the same length as 'times', \n  # otherwise use 'weights'\n  w <- if (is.null(weights)) rep(1, length(times)) else weights\n  \n  # Create a DataFrame 'data' with columns t (times), f (failures), \n  # v (stratification variable: often treatment variable), and w (weights)\n  data <- data.frame(t = times, f = failures, v = variable, w = w)\n  \n  # Remove rows from the DataFrame where the stratification variable is NA\n  data <- data[!is.na(data$v),]\n  \n  # Initialize an empty DataFrame to store the Kaplan-Meier results\n  table_KM <- data.frame(times = NULL, n.risk = NULL, n.event = NULL, \n                         survival = NULL, variable = NULL)\n  \n  # Loop over each unique value of the stratification variable\n  for (i in unique(variable)) {\n    # Subset the data for the current stratification variable value\n    d <- data[data$v == i,]\n    \n    # Create a sorted vector of unique event times, including time 0 and the \n    # maximum time\n    tj <- c(0, sort(unique(d$t[d$f == 1])), max(d$t))\n    \n    # Calculate the number of events at each time point\n    dj <- sapply(tj, function(x) {\n      sum(d$w[d$t == x & d$f == 1])\n    })\n    \n    # Calculate the number of individuals at risk at each time point\n    nj <- sapply(tj, function(x) {\n      sum(d$w[d$t >= x])\n    })\n    \n    # Compute the cumulative product for the survival probabilities\n    st <- cumprod((nj - dj) / nj)\n    \n    # Append the results to the Kaplan-Meier table\n    table_KM <- rbind(table_KM, data.frame(T = tj, n = nj, d = dj, \n                                           S = st, variable = i))\n  }\n  return(table_KM)\n}\n\n\n# IPCW Kaplan-Meier estimator with restricted tau\nIPCW_Kaplan_meier <- function(data, tau, \n                              X.names.censoring, \n                              nuisance_censoring = \"cox\", \n                              n.folds = NULL) {\n  \n  # Compute of truncated T_obs, status and censored status\n  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)\n  data$censor.status_tau <- 1 - as.numeric((data$T_obs >= tau) | \n                                             (data$T_obs < tau & data$status == 1))\n  data$status_tau <- as.numeric((data$T_obs >= tau) | \n                                  (data$T_obs < tau & data$status == 1))\n  Y.grid <- sort(unique(data$T_obs_tau))\n  \n  # Estimate probability of remaining uncensored based on nuisance model \n  S_C_hat <- estimate_survival_function(data = data, X.names = X.names.censoring,\n                                        Y.grid = Y.grid, T_obs = \"T_obs_tau\",\n                                        status = \"censor.status_tau\",\n                                        type_of_model = nuisance_censoring,\n                                        n.folds = n.folds)\n  \n  # Select the probability of censoring for each observed T_obs_tau from the \n  # curve\n  data$S_C <- S_C_hat$S_hat[cbind(1:nrow(data), match(data$T_obs_tau, Y.grid))]\n  \n  # Compute IPC weights\n  data$weights <- data$status_tau / data$S_C\n  \n  # Compute the adjusted IPCW Kaplan-Meier\n  S <- adjusted.KM(times = data$T_obs, failures = data$status, \n                   variable = data$A, weights = data$weights)\n\n  # Compute differenceof RMST between the two groups\n  RMST <- RMST_1(S_A1 = S[S$variable == 1,], S_A0 = S[S$variable == 0,], tau = tau)\n  \n  return(list(RMST = RMST$RMST,\n              intA1 = RMST$intA1,\n              intA0 = RMST$intA0,\n              weights = data$weights))\n}\n\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Alternative code to estimate IPCW Kaplan-Meier, IPTW Kaplan-Meier or \n# IPTW-IPCW Kaplan-Meier estimator with survival package instead of using \n# handmade adjusted.KM function (the weights need to be calculated before).\n\n# Weights0 corresponds to weights of the control and weights1 of treated\nAdjusted_Kaplan_meier_alternative <- function(data, A1 = 1, A0 = 0, tau, \n                                          weights0, weights1){\n  # Estimate Kaplan-Meier estimator with survfit function on data subset \n  # Groupe A = 0\n  fit0 <- survfit(Surv(T_obs, status) ~ 1, data = data[data$A == A0,], weights = weights0)  \n  # Groupe A = 1\n  fit1 <- survfit(Surv(T_obs, status) ~ 1, data = data[data$A == A1,], weights = weights1)  \n\n  # Estimate the RMST with rmean\n  summary_fit0 <- summary(fit0, rmean = tau)  # RMST for A = 0\n  summary_fit1 <- summary(fit1, rmean = tau)  # RMST for A = 1\n\n  # Extract the RMST from the summary objects\n  rmst0 <- summary_fit0$table[\"rmean\"][[1]]\n  rmst1 <- summary_fit1$table[\"rmean\"][[1]]\n\n  # Compute the difference in RMST between the two groups\n  difference_rmst <- rmst1 - rmst0\nreturn(difference_rmst)\n}\n```\n\nThis alternative approach for IPCW Kaplan-Meier would also be valid for IPTW and IPTW-IPCW Kaplan-Meier.\n\n**Buckley-James based estimator **\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Compute the Restricted Mean Survival Time (RMST) difference\nBJ <- function(data, tau, X.names.outcome = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n               nuisance = \"cox\", n.folds = NULL) {\n  # Truncate observed times at tau\n  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)\n  Y.grid <- sort(unique(data$T_obs_tau))\n  \n  # Censoring status at tau\n  data$status_tau <- as.numeric((data$T_obs >= tau) | \n                                (data$T_obs < tau & data$status == 1))\n  \n  # Compute Q_t for all time points\n  Q_t <- Q_t_hat(data, tau, X.names.outcome, nuisance, n.folds)\n  data$Q_y <- Q_Y(data, tau, Q_t)\n  \n  # Split data by treatment group\n  data_treated <- data %>% dplyr::filter(A == 1)\n  data_not_treated <- data %>% dplyr::filter(A == 0)\n  \n  # Calculate Restricted Survival Time (RST) for each group\n  data_treated$RST <- data_treated$status_tau * data_treated$T_obs_tau + \n                      (1 - data_treated$status_tau) * data_treated$Q_y\n  \n  data_not_treated$RST <- data_not_treated$status_tau * data_not_treated$T_obs_tau + \n                          (1 - data_not_treated$status_tau) * data_not_treated$Q_y\n  \n  # Calculate RMST difference between treated and not treated\n  RMST <- mean(data_treated$RST) - mean(data_not_treated$RST)\n  \n  # Return RMST and other relevant metrics\n  return(list(\n    RMST = RMST, \n    ATE_treated = mean(data_treated$RST), \n    ATE_not_treated = mean(data_not_treated$RST)\n  ))\n}\n```\n\n**IPTW Kaplan-Meier**\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Function to calculate IPTW Kaplan-Meier\nIPTW_Kaplan_meier <- function(data, tau, X.names.propensity, \n                              nuisance_propensity = \"glm\", n.folds = NULL) {\n  # Estimate propensity scores\n  data$e_hat <- estimate_propensity_score(\n    data,\n    treatment_covariates = X.names.propensity,\n    type_of_model = nuisance_propensity,\n    n.folds = n.folds)\n  \n  # Truncate observed times at tau\n  data$T_obs_tau <- pmin(data$T_obs, tau)\n  \n  # Define censoring status at tau\n  data$status_tau <- as.numeric((data$T_obs >= tau) | \n                                (data$T_obs < tau & data$status == 1))\n  \n  # Calculate weights\n  data$weights <- (data$A) * (1 / data$e_hat) + (1 - data$A) / (1 - data$e_hat)\n  \n  # Adjusted Kaplan-Meier estimator\n  S <- adjusted.KM(\n    times = data$T_obs, \n    failures = data$status,\n    variable = data$A, \n    weights = data$weights)\n  \n  # Calculate RMST from the adjusted survival curves\n  RMST <- RMST_1(S_A1 = S[S$variable == 1,], \n                 S_A0 = S[S$variable == 0,], \n                 tau = tau)\n  \n  return(list(\"intA0\" = RMST$intA0, \"intA1\" = RMST$intA1, \"RMST\" = RMST$RMST))\n}\n\n```\n\n**G-formula**\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Function to estimate the g-formula Two-learner.\ng_formula_T_learner <- function(data, \n                                X.names.outcome, \n                                tau, \n                                nuisance_survival = \"cox\", \n                                n.folds = NULL) {\n  # Compute min(T_obs,tau)\n  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)\n  \n  # Y.grid is the grid of time points where we want to estimate the \n  # survival function.\n  Y.grid <- sort(unique(data$T_obs_tau))\n  \n  S_hat <- estimate_survival_function(data, X.names.outcome, \n                                      Y.grid, \n                                      type_of_model = nuisance_survival,\n                                      T_obs = \"T_obs\", \n                                      status = \"status\", \n                                      n.folds = n.folds)\n  \n  # Compute the area under each survival curve up to max(Y.grid) = tau.\n  E_hat1 <- expected_survival(S_hat$S_hat1, Y.grid)\n  E_hat0 <- expected_survival(S_hat$S_hat0, Y.grid)\n  \n  # Calculate the mean difference.\n  theta_g_formula <- mean(E_hat1 - E_hat0)\n  \n  return(theta_g_formula)\n}\n\n# Function to estimate the g-formula Single-learner.\ng_formula_S_learner <- function(data, \n                                X.names.outcome, \n                                tau, \n                                nuisance_survival = \"cox\", \n                                n.folds = NULL) {\n  # Compute min(T_obs,tau)\n  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)\n  \n  # Y.grid is the grid of time points where we want to estimate the \n  # survival function.\n  Y.grid <- sort(unique(data$T_obs_tau))\n  \n  S_hat <- estimate_survival_function(data, X.names.outcome, \n                                      Y.grid, \n                                      type_of_model = nuisance_survival,\n                                      learner = \"S-learner\",\n                                      T_obs = \"T_obs\", \n                                      status = \"status\", \n                                      n.folds = n.folds)\n  \n  # Compute the area under each survival curve until max(Y.grid) = tau.\n  E_hat1 <- expected_survival(S_hat$S_hat1, Y.grid)\n  E_hat0 <- expected_survival(S_hat$S_hat0, Y.grid)\n  \n  # Calculate the mean difference.\n  theta_g_formula <- mean(E_hat1 - E_hat0)\n  \n  return(theta_g_formula)\n}\n\n```\n\n**IPTW-IPCW Kaplan-Meier**\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nIPTW_IPCW_Kaplan_meier <- function(data, \n                                   X.names.propensity, \n                                   X.names.censoring, \n                                   tau,\n                                   nuisance_propensity = \"glm\",\n                                   nuisance_censoring = \"cox\",\n                                   n.folds = NULL) {\n  # Censoring time to tau if observed time exceeds tau\n  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)\n  \n  # Create censoring status for tau\n  data$censor.status_tau <- 1 - as.numeric((data$T_obs >= tau) | \n                                           (data$T_obs < tau & data$status == 1))\n  \n  # Create status at tau\n  data$status_tau <- as.numeric((data$T_obs >= tau) | \n                                (data$T_obs < tau & data$status == 1))\n  \n  # Grid of unique observed times truncated at tau\n  Y.grid <- sort(unique(data$T_obs_tau))\n\n  # Estimate propensity scores\n  data$e_hat <- estimate_propensity_score(data,\n                                          treatment_covariates = X.names.propensity,\n                                          type_of_model = nuisance_propensity,\n                                          n.folds = n.folds)\n\n  # Estimate survival function for censoring\n  S_C_hat <- estimate_survival_function(data, X.names = X.names.censoring,\n                                        Y.grid = Y.grid, T_obs = \"T_obs_tau\",\n                                        status = \"censor.status_tau\",\n                                        type_of_model = nuisance_censoring,\n                                        n.folds = n.folds)\n\n  # Get estimated survival probabilities for censoring\n  data$S_C <- S_C_hat$S_hat[cbind(1:nrow(data), match(data$T_obs_tau, Y.grid))]\n\n  # Calculate weights\n  data$weights <- data$status_tau / data$S_C * \n                  (data$A * (1 / data$e_hat) + \n                     (1 - data$A) * (1 / (1 - data$e_hat)))\n\n  # Compute adjusted Kaplan-Meier estimator\n  S <- adjusted.KM(times = data$T_obs, \n                   failures = data$status, \n                   variable = data$A, \n                   weights = data$weights)\n\n  # Compute Restricted Mean Survival Time (RMST)\n  RMST <- RMST_1(S_A1 = S[S$variable == 1, ], \n                 S_A0 = S[S$variable == 0, ],\n                 tau = tau)\n\n  # Return RMST and ATE for treated and not treated groups\n  return(list(RMST = RMST$RMST, ATE_treated = RMST$intA1, \n              ATE_not_treated = RMST$intA0))\n}\n```\n\n**IPTW-BJ estimator**\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nIPTW_BJ <- function(data, \n                    X.names.propensity,\n                    X.names.outcome, \n                    tau,\n                    nuisance_propensity = \"glm\",\n                    nuisance = \"cox\",\n                    n.folds = NULL) {\n  # Minimum of T_obs and tau\n  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)\n  \n  # Grid of unique observed times truncated at tau\n  Y.grid <- sort(unique(data$T_obs_tau))\n  \n  # Indicator for min(T, tau) < C\n  data$status_tau <- as.numeric((data$T_obs >= tau) | \n                                (data$T_obs < tau & data$status == 1))\n  \n\n  # Estimate propensity scores\n  data$e_hat <- estimate_propensity_score(data,\n                                          treatment_covariates = X.names.propensity,\n                                          type_of_model = nuisance_propensity,\n                                          n.folds = n.folds)\n\n\n  # Estimation of Q_s\n  Q_t <- Q_t_hat(data, tau, X.names.outcome, nuisance, n.folds)\n  data$Q_y <-  Q_Y(data,tau,Q_t)\n  \n  # BJ transformation\n  data$Y <-  data$status_tau * data$T_obs_tau + \n                             (1 - data$status_tau) * data$Q_y\n  \n  # IPTW on BJ transformation \n  data$RST <- data$Y * (data$A/data$e_hat-(1-data$A)/(1-data$e_hat))\n  \n  RMST <- mean(data$RST)\n  \n  # Return RMST\n  return(RMST)\n}\n```\n\n**AIPTW-AIPCW**\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# DR censoring transformation\nAIPCW <-function(data,\n                 tau,\n                 X.names.censoring = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n                 X.names.outcome = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n                 nuisance_Qt = \"cox\",\n                 nuisance_censoring = \"cox\", \n                 n.folds = NULL, \n                 h_C_hat = NULL,\n                 method_aipw = 1) {\n  \n  # Truncate observed times at tau\n  data$T_obs_tau <- pmin(data$T_obs, tau)\n  \n  # Define status at tau\n  data$status_tau <-  as.numeric((data$T_obs > tau) | \n                                  (data$T_obs <= tau &  data$status == 1 ))  \n\n  data$censor.status_tau <- 1- as.numeric(\n    (data$T_obs > tau) | (data$T_obs <= tau &  data$status == 1 ))\n \n  Y.grid <- sort(unique(data$T_obs_tau))\n  \n  # Estimate survival function for censoring\n  S_C_hat <- estimate_survival_function(data = data,X.names.censoring,\n                                        type_of_model = nuisance_censoring,\n                                        n.folds = n.folds,\n                                        Y.grid = Y.grid,\n                                        T_obs = \"T_obs_tau\",\n                                        status = \"censor.status_tau\")\n  \n  Y.index <- findInterval(data$T_obs_tau, Y.grid)\n  \n  data$S_C_hat_T_obs_tau <- S_C_hat$S_hat[cbind(seq_along(Y.index), Y.index)]\n\n  \n  if (is.null(h_C_hat)) {\n      h_C_hat <- estimate_hazard_function(S_C_hat$S_hat,Y.grid)\n  } \n  \n  # Compute Q.t.hat\n  Q.t.hat <- Q_t_hat(data = data,\n                     X.names = X.names.outcome,\n                     tau = tau,\n                     nuisance = nuisance_Qt,\n                     n.folds = n.folds)\n  \n  # Compute Q.Y.hat\n  data$Q.Y.hat <- Q_Y(data = data, tau, Q.t.hat)\n\n  # Compute first term\n  data$first_term <- (data$T_obs_tau * data$status_tau) / \n    data$S_C_hat_T_obs_tau\n  \n  # Compute second term\n  data$second_term <- (data$Q.Y.hat * (1 - data$status_tau)) / \n    data$S_C_hat_T_obs_tau\n  \n  Y.diff <- diff(c(0, Y.grid))\n  \n  # Compute integrand for the third term\n  integrand <- sweep( ( (h_C_hat) / S_C_hat$S_hat )* (Q.t.hat), 2, Y.diff, \"*\")\n  \n  # Compute third term\n  data$third_term <- integrate(integrand, Y.grid, data$T_obs_tau)\n  \n  # Compute pseudo outcome\n  pseudo_outcome <- data$first_term + data$second_term - data$third_term\n\n  return(pseudo_outcome) \n}\n\n\nAIPTW_AIPCW <- function(data, \n                        tau, \n                        X.names.propensity = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n                        X.names.censoring = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n                        X.names.outcome = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n                        nuisance_propensity = \"glm\",\n                        nuisance_regression = \"cox\",\n                        nuisance_censoring = \"cox\",\n                        nuisance_Qt = \"cox\",\n                        n.folds = NULL) {\n  \n  # Estimate propensity scores\n  data$e_hat <- estimate_propensity_score(\n    data = data, \n    treatment_covariates = X.names.propensity, \n    type_of_model = nuisance_propensity, \n    n.folds = n.folds\n  )\n  \n  # Prepare data for censoring model\n  data$T_obs_tau <- ifelse(data$T_obs >= tau, tau, data$T_obs)\n  \n  data$censor.status_tau <- 1 - as.numeric((data$T_obs >= tau) | \n                                             (data$T_obs < tau & data$status == 1))\n  \n  data$status_tau <- as.numeric((data$T_obs >= tau) | \n                                  (data$T_obs < tau & data$status == 1))\n  \n  # Create unique time grid\n  Y.grid <- sort(unique(data$T_obs_tau))\n  \n  S_hat <- estimate_survival_function(data, X.names.outcome, \n                                      type_of_model = nuisance_regression, \n                                      Y.grid = Y.grid,\n                                      T_obs= \"T_obs\", \n                                      status = \"status\", \n                                      n.folds = n.folds)\n  \n  # Compute area under the survival curve up to tau\n  data$E_hat1 <- expected_survival(S_hat$S_hat1, Y.grid)\n  data$E_hat0 <- expected_survival(S_hat$S_hat0, Y.grid)\n  \n  # Compute IPW-weighted residuals\n  data$IPW_res <- data$E_hat1 * (1 - data$A / data$e_hat) - \n    data$E_hat0 * (1 - (1 - data$A) / (1 - data$e_hat))\n  \n  # Compute AIPCW weights\n  TDR <- AIPCW(\n    data = data, \n    tau = tau,\n    X.names.censoring = X.names.censoring,\n    X.names.outcome = X.names.outcome,\n    nuisance_Qt = nuisance_Qt, \n    nuisance_censoring = nuisance_censoring, \n    n.folds = n.folds\n  )\n  \n  data$TDR <- TDR\n  \n  # Compute AIPCW-weighted residuals\n  data$AIPCW_w <- data$TDR * (data$A / data$e_hat - \n                                (1 - data$A) / (1 - data$e_hat))\n  \n  # Compute regression residuals\n  data$reg <- data$E_hat1 - data$E_hat0\n  data$reg_res <- data$A / data$e_hat * (data$TDR - data$E_hat1) - \n    (1 - data$A) / (1 - data$e_hat) * (data$TDR - data$E_hat0)\n  \n  # Compute estimators\n  # na.rm = TRUE to remove NA for the mean calculation\n  AIPTW_AIPCW_IPW_res <- mean(data$AIPCW_w + data$IPW_res, na.rm = TRUE)\n  AIPTW_AIPCW_reg_res <- mean(data$reg + data$reg_res, na.rm = TRUE)\n  \n  return(list(AIPTW_AIPCW_reg_res = AIPTW_AIPCW_reg_res, \n              AIPTW_AIPCW_IPW_res = AIPTW_AIPCW_IPW_res))\n}\n\n```\n\n# Simulations\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n############ RCT \n# RCT1:  Random treatment assignment + independent censoring\n# RCT2:  Random treatment assignment + dependent censoring (conditional on X \n# and A)\nsimulate_data_RCT <- function(n, mu = c(1, 1, -1, 1), \n                              sigma = diag(4), \n                              colnames_cov = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n                              tau, \n                              coefT0 = 0.01,\n                              parsS = c(0.5, 0.5, -0.5, 0.5), \n                              coefC = 0.03,\n                              parsC = c(0.7, 0.3, -0.25, -0.1), \n                              parsC_A = c(-0.2), \n                              scenario = \"RCT2\",\n                              mis_specification=\"none\") {\n  \n  # Generate X from a multivariate normal distribution\n  X <- MASS::mvrnorm(n, mu, sigma)\n  X <- as.data.frame(X)\n  colnames(X) <- colnames_cov\n  \n  # Treatment variable selection: all X\n  X_treatment <- as.matrix(X)\n  \n  # Propensity score: constant for random assignment\n  e <- rep(0.5, n)\n  \n  # Random treatment assignment\n  A <- sapply(e, FUN = function(p) rbinom(1, 1, p))\n  \n  # Outcome variable selection: all X\n  X_outcome <- as.matrix(X)\n  \n  # Simulate the outcome using the cumulative hazard inversion method\n  epsilon <- runif(n, min = 1e-8, max = 1)\n  T0 <- -log(epsilon) / (coefT0 * exp(X_outcome %*% parsS))\n  \n  if (scenario == \"RCT1\") {\n    # Simulate independent censoring time\n    epsilon <- runif(n, min = 1e-8, max = 1)\n    C <- -log(epsilon) / coefC\n  }\n  else if (scenario == \"RCT2\") {\n    # Simulate dependent censoring time\n    X_censoring <- as.matrix(cbind(X,A))\n    parsC <- c(parsC,parsC_A)\n    \n    epsilon <- runif(n, min = 1e-8, max = 1)\n    C <- -log(epsilon) / (coefC * exp(rowSums(X_censoring %*% diag(parsC))))\n  }\n  # T(1) = T(0) + 10\n  T1 <- T0 + 10\n  \n  # True survival time\n  T_true <- A * T1 + (1 - A) * T0\n  \n  # Observed time\n  T_obs <- pmin(T_true, C)\n  \n  # Status indicator\n  status <- as.numeric(T_true <= C)\n  censor.status <- as.numeric(T_true > C)\n  \n  # Restricted survival time\n  T_obs_tau <- pmin(T_obs, tau)\n  status_tau <- as.numeric((T_obs > tau) | (T_obs <= tau & status == 1))\n  \n  # Combine all data into a single data frame\n  data_target_population <- data.frame(X, tau, A, T0, T1, C, T_obs, T_obs_tau, \n                                       status, censor.status, status_tau, e)\n  \n  return(data_target_population)\n}\n\n```\n\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# data_rct1 simulate the data from RCT with independent censoring \ndata_rct1 <- simulate_data_RCT(n=2000,\n                               tau=25,\n                               scenario=\"RCT1\",\n                               coefC = 0.03)\n# Stratification by treatment \ngroup_0 <- data_rct1 %>%\n  dplyr:: filter(A == 0)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,T_tild=T_obs)\n\ngroup_1 <- data_rct1 %>%\n  dplyr:: filter(A == 1)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,T_tild=T_obs)\n\n# Summary statistics\nsummary_group_0 <- summary(group_0)\nsummary_group_1 <- summary(group_1)\n\nprint(paste(\"Descriptive statistics for group A=0:  \",nrow(group_0)))\nprint(summary_group_0)\n\nprint(paste(\"Descriptive statistics for group A=1:  \",nrow(group_1)))\nprint(summary_group_1)\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n\n# data_rct2 simulate the data from RCT with dependent censoring \ndata_rct2 <- simulate_data_RCT(n=2000,\n                               tau=25,\n                               scenario=\"RCT2\", \n                               coefC = 0.03, \n                               parsC = c(0.7,0.3,-0.25,-0.1),\n                               parsC_A = c(-0.2))\n\n\n# Stratification by treatment \ngroup_0 <- data_rct2 %>%\n  dplyr:: filter(A == 0)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,status_tau,T_tild=T_obs)\n\ngroup_1 <- data_rct2 %>%\n  dplyr:: filter(A == 1)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,status_tau,T_tild=T_obs)\n\n# Summary statistics\nsummary_group_0 <- summary(group_0)\nsummary_group_1 <- summary(group_1)\n\nprint(paste(\"Descriptive statistics for group A=0:  \",nrow(group_0)))\nprint(summary_group_0)\n\nprint(paste(\"Descriptive statistics for group A=1:  \",nrow(group_1)))\nprint(summary_group_1)\n\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Function to calculate ground truth for RCT and Observational data\nground_truth <- function(tau, \n                         data) {\n  # Compute RMST with the true T1\n  data$T1_tau <- ifelse(data$T1 >= tau, tau, data$T1)\n  \n  # Compute RMST with the true T0\n  data$T0_tau <- ifelse(data$T0 >= tau, tau, data$T0)\n  \n  # Compute the difference in RMST if everyone had the treatment \n  # and if everyone had the control\n  truth <- mean(data$T1_tau) - mean(data$T0_tau)\n  \n  return(truth)\n}\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Set initial tau value\ntau <- 25\n# Define vector of tau values\nvec_tau <- seq(1, 150, by = 1)\n\n# Function to plot the ground truth RMST for different scenarios\nplot_ground_truth <- function(data, vec_tau, tau, ylim, title_text) {\n  truth <- sapply(vec_tau, function(x) ground_truth(tau = x, data))\n  matplot(\n    vec_tau, truth, type = \"l\", lty = 1, col = 1,\n    ylab = \"RMST\", xlab = \"tau\", ylim = ylim\n  )\n  abline(v = tau, col = \"red\", lty = 2)\n  abline(h = truth[vec_tau == tau], col = \"red\", lty = 2)\n  title(title_text, cex.main = 0.9)  # Adjusting title text size\n}\n\n# Simulation for scenario RCT1\ndata_RCT1 <- simulate_data_RCT(\n  n = 100000, tau = tau, scenario = \"RCT1\")\n\nplot_ground_truth(data_RCT1, \n                  vec_tau, \n                  tau, \n                  c(0, 10), \n                  \"True difference in RMST for RCT scenario 1\")\n\ntruth_tau1 <- ground_truth(data_RCT1, tau = 25)\nprint(paste0(\"The ground truth for RCT scenario 1 and 2 at time 25 is \", round(truth_tau1, 1)))\ntruth_tau2 <- truth_tau1\n```\n\n\n```{r}\n# Function to launch the previous implemented functions in a \n# specified scenario, sample size.\nall_estimates <- function(data, sample.size, tau, \n                           X.names.propensity,\n                           X.names.censoring,\n                           X.names.outcome,\n                           nuisance_propensity = \"glm\", \n                           nuisance_censoring = \"cox\", \n                           nuisance_survival = \"cox\", \n                           n.folds = NULL,\n                           estimator = \"all\") {\n  \n  # List of available estimators\n  available_estimators <- c(\n    \"Naive\", \"KM\", \"IPTW KM\", \"IPCW KM\", \"BJ\", \n    \"IPTW-IPCW KM\", \"IPTW-BJ\", \"G_formula (T-learners)\", \n    \"G_formula (S-learner)\", \"AIPTW-AIPCW\", \"SurvRM2 - KM\", \n    \"grf - Causal Survival Forest\", \"RISCA - IPTW KM\", \n    \"RISCA - G_formula (S-learner)\"\n  )\n  \n  # If estimator is \"all\", we select all the estimators in \n  # available_estimators\n  if (\"all\" %in% estimator) {\n    estimator <- available_estimators\n  }\n  \n  # Filter the selected estimators\n  estimator <- intersect(estimator, available_estimators)\n  \n  # Store the results in a data frame\n  results <- data.frame(\n    \"sample.size\" = numeric(),\n    \"estimate\" = numeric(),\n    \"estimator\" = character(),\n    \"nuisance\" = character()\n  )\n  \n  # Function to extract variable names from I() for squared terms and interaction terms\n  extract_vars <- function(names) {\n    # Extract names from squared terms\n    extracted_squared <- gsub(\"I\\\\((.*)\\\\^2\\\\)\", \"\\\\1\", names)  # Replace \"I(X^2)\" with \"X\"\n    # Extract names from interaction terms (e.g., \"X1:X2\" becomes \"X1\" and \"X2\")\n    result_vector <- unique(unlist(strsplit(extracted_squared, \":\")))\n    return(unique(result_vector))\n  }\n  # Combine all vectors\n  all_names <- c(X.names.propensity, X.names.outcome, X.names.censoring)\n  # Apply the extraction function\n  X.names <- extract_vars(all_names)\n  \n  # Each estimator is computed if selected\n  # Naive estimator\n  if (\"Naive\" %in% estimator) {\n    ATE_naive <- Naive(data, tau)\n    results <- rbind(results, data.frame(\n      \"sample.size\" = sample.size, \"estimate\" = ATE_naive, \n      \"estimator\" = \"Naive\", \"nuisance\" = \"\"\n    ))\n  }\n  # RMST estimate with undajusted KM\n  if (\"KM\" %in% estimator) {\n    ATE_km_rct <- RMST_1(data, tau = tau)\n    results <- rbind(results, data.frame(\n      \"sample.size\" = sample.size, \"estimate\" = ATE_km_rct$RMST, \n      \"estimator\" = \"KM\", \"nuisance\" = \"\"\n    ))\n  }\n  # RMST estimate with IPTW KM\n  if (\"IPTW KM\" %in% estimator) {\n    for (propensity_method in nuisance_propensity) {\n      ATE_km_adj <- IPTW_Kaplan_meier(data, tau = tau, \n                                      X.names.propensity = X.names.propensity, \n                                      nuisance_propensity = propensity_method, \n                                      n.folds = n.folds)\n      if (propensity_method == \"probability forest\"){propensity_name = \"Forest\"}\n      else{propensity_name = \"Log. Reg.\"}\n      est_name <- paste(\"IPTW KM (\", propensity_name, \")\", sep = \"\")\n      results <- rbind(results, data.frame(\n        \"sample.size\" = sample.size, \"estimate\" = ATE_km_adj$RMST, \n        \"estimator\" = est_name, \"nuisance\" = propensity_method\n      ))\n    }\n  }\n  \n  # RMST estimate with IPCW KM\n  if (\"IPCW KM\" %in% estimator) {\n    for (censoring_method in nuisance_censoring) {\n      ATE_IPCW <- IPCW_Kaplan_meier(data, X.names.censoring = X.names.censoring, \n                                    tau = tau, \n                                    nuisance_censoring = censoring_method, \n                                    n.folds = n.folds)\n      if (censoring_method == \"survival forest\"){censoring_name = \"Forest\"}\n      else{censoring_name = \"Cox\"}\n      est_name <- paste(\"IPCW KM (\", censoring_name, \")\", sep = \"\")\n      results <- rbind(results, data.frame(\n        \"sample.size\" = sample.size, \"estimate\" = ATE_IPCW$RMST, \n        \"estimator\" = est_name , \"nuisance\" = censoring_method\n      ))\n    }\n  }\n  # RMST estimate with BJ pseudo observations\n  if (\"BJ\" %in% estimator) {\n    for (survival_method in nuisance_survival) {\n      ATE_bj <- BJ(data, tau = tau, \n                   X.names.outcome = X.names.outcome,\n                   nuisance = survival_method, \n                   n.folds = n.folds)\n      if (survival_method == \"survival forest\"){survival_name = \"Forest\"}\n      else{survival_name = \"Cox\"}\n      est_name <- paste(\"BJ (\", survival_name, \")\", sep = \"\")\n      results <- rbind(results, data.frame(\n        \"sample.size\" = sample.size, \"estimate\" = ATE_bj$RMST, \n        \"estimator\" = est_name, \"nuisance\" = survival_method\n      ))\n    }\n  }\n  \n  # RMST estimate with g-formula two-learners\n  if (\"G_formula (T-learners)\" %in% estimator) {\n    for (survival_method in nuisance_survival) {\n      ATE_g_formula_t <- g_formula_T_learner(data, tau = tau, \n                                             X.names.outcome = X.names.outcome, \n                                             nuisance_survival = survival_method, \n                                             n.folds = n.folds)\n      if (survival_method == \"survival forest\"){survival_name = \"Forest\"}\n      else{survival_name = \"Cox\"}\n      est_name <- paste(\"G-formula (\", survival_name, \"/ T-learners)\", sep = \"\")\n      results <- rbind(results, data.frame(\n        \"sample.size\" = sample.size, \"estimate\" = ATE_g_formula_t, \n        \"estimator\" = est_name, \n        \"nuisance\" = survival_method\n      ))\n    }\n  }\n  \n  # RMST estimate with g-formula single learner\n  if (\"G_formula (S-learner)\" %in% estimator) {\n    for (survival_method in nuisance_survival) {\n      ATE_g_formula_s <- g_formula_S_learner(data, tau = tau, \n                                             X.names.outcome = X.names.outcome, \n                                             nuisance_survival = survival_method, \n                                             n.folds = n.folds)\n      if (survival_method == \"survival forest\"){survival_name = \"Forest\"}\n      else{survival_name = \"Cox\"}\n      est_name <- paste(\"G-formula (\", survival_name, \"/ S-learner)\", sep = \"\")\n      results <- rbind(results, data.frame(\n        \"sample.size\" = sample.size, \"estimate\" = ATE_g_formula_s, \n        \"estimator\" = est_name, \n        \"nuisance\" = survival_method\n      ))\n    }\n  }\n  \n  \n  # RMST estimate with IPTW with pseudo observations (BJ transformation)\n  if (\"IPTW-BJ\" %in% estimator) {\n    for (survival_method in nuisance_survival) {\n      for (propensity_method in nuisance_propensity) {\n        ATE_IPTW_bj <- IPTW_BJ(data, tau = tau, \n                               X.names.propensity = X.names.propensity, \n                               X.names.outcome = X.names.outcome, \n                               nuisance_propensity = propensity_method, \n                               nuisance = survival_method, \n                               n.folds = n.folds)\n        if (survival_method == \"survival forest\"){survival_name = \"Forest\"}\n        else{survival_name = \"Cox\"}\n        if (propensity_method == \"probability forest\"){propensity_name = \"Forest\"}\n        else{propensity_name = \"Log. Reg.\"}\n        if (propensity_name  == survival_name){\n          est_name <- paste(\"IPTW-BJ (\", survival_name, \")\", sep = \"\")\n        }\n        else{\n          est_name <- paste(\"IPTW-BJ (\", survival_name,\" & \", propensity_name , \")\", \n                            sep = \"\")}\n        \n        \n        results <- rbind(results, data.frame(\n          \"sample.size\" = sample.size, \"estimate\" = ATE_IPTW_bj, \n          \"estimator\" = est_name, \n          \"nuisance\" = paste(survival_method, propensity_method, sep = \", \")\n        ))\n      }\n    }\n  }\n  \n  # RMST estimate with IPTW-IPCW KM\n  if (\"IPTW-IPCW KM\" %in% estimator) {\n    for (censoring_method in nuisance_censoring) {\n      for (propensity_method in nuisance_propensity) {\n        ATE_iptw_ipcw_km <- IPTW_IPCW_Kaplan_meier(data, tau = tau, \n                                                   X.names.propensity = X.names.propensity, \n                                                   X.names.censoring = X.names.censoring, \n                                                   nuisance_propensity = propensity_method, \n                                                   nuisance_censoring = censoring_method, \n                                                   n.folds = n.folds)\n        if (censoring_method == \"survival forest\"){censoring_name = \"Forest\"}\n        else{censoring_name = \"Cox\"}\n        if (propensity_method == \"probability forest\"){propensity_name = \"Forest\"}\n        else{propensity_name = \"Log. Reg.\"}\n        if (propensity_name  == censoring_name){\n          est_name <- paste(\"IPTW-IPCW KM (\", censoring_name , \")\", \n                            sep = \"\")\n        }\n        else{\n          est_name <- paste(\"IPTW-IPCW KM (\", censoring_name,\" & \", propensity_name , \")\", \n                            sep = \"\")}\n        results <- rbind(results, data.frame(\n          \"sample.size\" = sample.size, \"estimate\" = ATE_iptw_ipcw_km$RMST, \n          \"estimator\" = est_name, \n          \"nuisance\" = paste(censoring_method, propensity_method, sep = \", \")\n        ))\n      }\n    }\n  }\n  \n  \n  # RMST estimate with AIPTW with pseudo observations (AIPCW transformation)\n  if (\"AIPTW-AIPCW\" %in% estimator) {\n    for (survival_method in nuisance_survival) {\n      for (propensity_method in nuisance_propensity) {\n        for (censoring_method in nuisance_censoring) {\n          ATE_aiptw_aipcw <- AIPTW_AIPCW(data, tau = tau, \n                                         X.names.propensity = X.names.propensity, \n                                         X.names.censoring = X.names.censoring, \n                                         X.names.outcome = X.names.outcome,\n                                         nuisance_propensity = propensity_method, \n                                         nuisance_censoring = censoring_method, \n                                         nuisance_Qt = survival_method, \n                                         n.folds = n.folds)\n          if (survival_method == \"survival forest\"){survival_name = \"Forest\"}\n          else{survival_name = \"Cox\"}\n          if (propensity_method == \"probability forest\"){\n            propensity_name = \"Forest\"}\n          else{propensity_name = \"Log. Reg.\"}\n          if (censoring_method == \"survival forest\"){\n            censoring_name = \"Forest\"}\n          else{censoring_name = \"Cox\"}\n          if (censoring_name == propensity_name & censoring_name == survival_name){\n            est_name <- paste(\"AIPTW-AIPCW (\", survival_name, \")\", sep = \"\")\n          }\n          else{\n            est_name <- paste(\"AIPTW-AIPCW (\", survival_name,\" & \", \n                              censoring_name ,\" & \", propensity_name , \")\", sep = \"\")}\n          results <- rbind(results, data.frame(\n            \"sample.size\" = sample.size, \n            \"estimate\" = ATE_aiptw_aipcw$AIPTW_AIPCW_IPW_res, \n            \"estimator\" = est_name, \n            \"nuisance\" = paste(survival_method, \n                               censoring_method, \n                               propensity_method , sep = \", \")\n          ))\n        }\n      }\n    }\n  }\n  \n  # Unadjusted estimate using package from SurvRM2\n  if (\"SurvRM2 - KM\" %in% estimator) {\n    ATE_pack <- tryCatch({\n      theta_rmst_survrm2(data, tau = tau)\n    }, error = function(e) {\n      message(\"Error in ATE_pack: \", e$message)\n      return(NA) \n    })\n    results <- rbind(results, data.frame(\n      \"sample.size\" = sample.size, \"estimate\" = ATE_pack, \n      \"estimator\" = \"SurvRM2 - KM\", \"nuisance\" = \"\"\n    ))\n  }\n  # Estimate using survival random forest from grf\n  # CSF can have a misspecification only on all nuisance parameters\n  if (\"grf - Causal Survival Forest\" %in% estimator) {\n    ATE_RF <- tryCatch({\n      # If there is no misspecification, X.names has to be defined as the \n      # union of all the covariates which influence nuisance models\n      CSRF(data, X.names, tau = tau)\n    }, error = function(e) {\n      message(\"Error in ATE_RF: \", e$message)\n      return(NA) \n    })\n    results <- rbind(results, data.frame(\n      \"sample.size\" = sample.size, \"estimate\" = ATE_RF, \n      \"estimator\" = \"grf - Causal Survival Forest\", \n      \"nuisance\" = \"\"\n    ))\n  }\n  \n  if (\"RISCA - IPTW KM\" %in% estimator) {\n    for (propensity_method in nuisance_propensity) {\n      # IPTW estimate from RISCA\n      ATE_RISCA_iptw <- tryCatch({\n        RISCA_iptw(data, X.names.propensity, propensity_method, tau = tau, \n                   n.folds=n.folds)\n      }, error = function(e) {\n        message(\"Error in ATE_RISCA_iptw: \", e$message)\n        return(NA) \n      })\n      if (propensity_method == \"probability forest\"){propensity_name = \"Forest\"}\n      else{propensity_name = \"Log. Reg.\"}\n      est_name <- paste(\"RISCA - IPTW KM (\", propensity_name, \")\", sep = \"\")\n      results <- rbind(results, data.frame(\n        \"sample.size\" = sample.size, \"estimate\" = ATE_RISCA_iptw, \n        \"estimator\" = est_name, \n        \"nuisance\" = propensity_method\n      ))\n    }\n  }\n  # Only support Cox object\n  if (\"RISCA - G_formula (S-learner)\" %in% estimator) {\n    # G-formula estimate from RISCA\n    ATE_RISCA_gf <- tryCatch({\n      RISCA_gf(data, X.names.outcome, tau = tau)\n    }, error = function(e) {\n      message(\"Error in ATE_RISCA_gf: \", e$message)\n      return(NA) \n    })\n    results <- rbind(results, data.frame(\n      \"sample.size\" = sample.size, \"estimate\" = ATE_RISCA_gf, \n      \"estimator\" = \"RISCA - G_formula (S-learner)\", \n      \"nuisance\" = \"Cox\"\n    ))\n  }\n  return(results)\n}\n\n\n# Function to compute estimators for multiple simulations and sample sizes\ncompute_estimator <- function(n_sim, tau, scenario = \"RCT1\", \n                              X.names.propensity, \n                              X.names.outcome,\n                              X.names.censoring,\n                              nuisance_propensity = \"glm\", \n                              nuisance_censoring = \"cox\", \n                              nuisance_survival = \"cox\", \n                              n.folds_propensity = NULL,\n                              n.folds_censoring = NULL, \n                              n.folds_survival = NULL, coefC = NULL, \n                              parsC = NULL,\n                              parsC_A = NULL,\n                              estimator = \"all\",\n                              sample_sizes = c(500, 1000, 2000, 4000, 8000)) {\n  \n  pb_n <- txtProgressBar(min = 0, max = length(sample_sizes), \n                         style = 3, initial = 0, char = \"#\")\n  on.exit(close(pb_n))\n  \n  results <- data.frame(\n    \"sample.size\" = numeric(),\n    \"estimate\" = numeric(),\n    \"estimator\" = character(),\n    \"nuisance\" = character()\n  )\n  \n  # Loop through each sample size\n  for (idx_n in seq_along(sample_sizes)) {\n    n <- sample_sizes[idx_n]\n    \n    # Progress bar for simulations\n    pb <- txtProgressBar(min = 0, max = n_sim, style = 3, initial = 0, char = \"#\")\n    on.exit(close(pb))\n    \n    # Loop through each simulation\n    for (i in 1:n_sim) {\n      setTxtProgressBar(pb, i)\n      \n      # Simulate data based on the scenario\n      if (scenario == \"RCT1\") {\n        data <- simulate_data_RCT(n, tau = tau, \n                                  scenario = \"RCT1\")\n      } else if (scenario == \"RCT2\") {\n        data <- simulate_data_RCT(n, tau = tau, \n                                  scenario = \"RCT2\", \n                                  coefC = coefC, \n                                  parsC = parsC,\n                                  parsC_A = parsC_A)\n      } else if (scenario == \"Obs1\") {\n        data <- simulate_data_obs(n, tau = tau, \n                                  scenario = \"Obs1\")\n      } else if (scenario == \"Obs2\") {\n        data <- simulate_data_obs(n, tau = tau, \n                                  scenario = \"Obs2\", \n                                  coefC = coefC, \n                                  parsC = parsC)\n      } else if (scenario == \"Complex\") {\n        data <- simulate_data_complex(n, \n                                      tau = tau,\n                                      parsC = parsC)\n      } else if (scenario == \"Mis\") {\n        data <- simulate_data_mis(n, tau = tau)\n      }\n      \n      \n      # Compute all estimates for the simulated data\n      all <- all_estimates(data, n, tau = tau, \n                           X.names.propensity, \n                           X.names.outcome,\n                           X.names.censoring,\n                           nuisance_propensity, \n                           nuisance_censoring,\n                           nuisance_survival, \n                           n.folds_propensity = n.folds_propensity, \n                           n.folds_censoring = n.folds_censoring, \n                           n.folds_survival = n.folds_survival,\n                           estimator)\n      results <- rbind(all, results)\n    }\n    \n    close(pb)\n    setTxtProgressBar(pb_n, idx_n)\n  }\n  \n  return(results)\n}\n\n```\n\n\n\n```{r,eval=FALSE}\n# Number of simulations and tau value\nn_sim <- 100\ntau <- 25\n\n# RCT1 simulation\nsimulation_rct1 <- compute_estimator(\n      n_sim, tau = tau, scenario = \"RCT1\", \n      X.names.propensity = c(\"X1\", \"X2\", \"X3\", \"X4\"), \n      X.names.outcome = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n      X.names.censoring = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n      nuisance_propensity = c(\"glm\", \"probability forest\"), \n      nuisance_censoring = c(\"cox\", \"survival forest\"), \n      nuisance_survival = c(\"cox\", \"survival forest\"), \n      n.folds_propensity = 5,\n      n.folds_censoring = 5,\n      n.folds_survival = 5,\n      coefC = 0.03\n)\nsave(simulation_rct1, file = \"simulation_rct1.RData\")\n\n# RCT2 simulation with specific coefficients and parameters\nsimulation_rct2 <- compute_estimator(\n  n_sim, tau = tau, scenario = \"RCT2\", \n  X.names.propensity = c(\"X1\", \"X2\", \"X3\", \"X4\"), \n  X.names.outcome = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n  X.names.censoring = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n  nuisance_propensity = c(\"glm\", \"probability forest\"), \n  nuisance_censoring = c(\"cox\", \"survival forest\"), \n  nuisance_survival = c(\"cox\", \"survival forest\"), \n  n.folds_propensity = 5,\n  n.folds_censoring = 5,\n  n.folds_survival = 5,\n  coefC = 0.03, \n  parsC = c(0.7, 0.3, -0.25, -0.1), \n  parsC_A = 0\n)\nsave(simulation_rct2, file = \"simulation_rct2.RData\")\n\n```\n\n```{r}\nload(\"simulations/simulation_rct1.RData\")\nload(\"simulations/simulation_rct2.RData\")\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Update the theme to center the plot title\ntheme_update(plot.title = element_text(hjust = 0.5))\n\n# Define the desired order of the estimators\n\ndesired_order <- c(\n  \"Naive\",\n  \"KM\",\n  \"SurvRM2 - KM\",\n  \"IPTW KM (Log. Reg.)\",\n  \"RISCA - IPTW KM (Log. Reg.)\",\n  \"IPCW KM (Cox)\",\n  \"BJ (Cox)\",\n  \"IPTW-BJ (Cox & Log. Reg.)\",\n  \"IPTW-IPCW KM (Cox & Log. Reg.)\",\n  \"G-formula (Cox/ T-learners)\",\n  \"G-formula (Cox/ S-learner)\",\n  \"RISCA - G_formula (S-learner)\",\n  \"AIPTW-AIPCW (Cox & Cox & Log. Reg.)\",\n  \"grf - Causal Survival Forest\",\n  \"IPTW KM (Forest)\",\n  \"RISCA - IPTW KM (Forest)\",\n  \"IPCW KM (Forest)\",\n  \"BJ (Forest)\",\n  \"IPTW-BJ (Forest)\",\n  \"IPTW-IPCW KM (Forest)\",\n  \"G-formula (Forest/ T-learners)\",\n  \"G-formula (Forest/ S-learner)\",\n  \"AIPTW-AIPCW (Forest)\")\n\n# Convert sample size to a factor with levels sorted in decreasing order\nsimulation_rct1$sample.size <- factor(\n  simulation_rct1$sample.size, \n  levels = sort(unique(simulation_rct1$sample.size), decreasing = FALSE)\n)\n\n# Convert estimator column to a factor with the specified order\nsimulation_rct1$estimator <- factor(simulation_rct1$estimator, \n                                    levels = desired_order)\n\n# Create the plot for RCT + independent censoring\nsimulation_graph_rct1 <- simulation_rct1 %>%\n  ggplot(aes(\n    x = estimator, y = estimate,  \n    fill = factor(sample.size, levels = rev(levels(sample.size)))\n  )) +\n  scale_fill_brewer(palette = \"Accent\") +\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +  # Change x-axis label\n  ylab(\"ATE\") +  # Change y-axis label\n  stat_boxplot(geom = \"errorbar\") +\n  geom_hline(\n    yintercept = truth_tau1, linetype = \"dashed\", color = \"red\", \n    alpha = 0.8, size = 0.8\n  ) +\ntheme(\n    legend.title = element_blank(), legend.position = \"bottom\",\n    legend.box = \"vertical\", legend.text = element_text(size = 18),\n    axis.text.x = element_text(angle = 35, vjust = 1, hjust = 1),  \n    # Adjust text angle for better visibility\n    axis.text = element_text(size = 15, face = \"bold\"),\n    axis.title.x = element_text(size = 16, face = \"bold\"),\n    plot.margin = margin(t = 10, r = 10, b = 50, l = 10)  # Add margin\n  ) +    \n  coord_cartesian(ylim = c(0, 15))\n  \n```\n\n```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}\n#| label: fig-rct1\n#| fig-cap: \"Results of the ATE for the simulation of a RCT with independent censoring.\"\n#| warning: false\nsimulation_graph_rct1 \n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Update the theme to center the plot title\ntheme_update(plot.title = element_text(hjust = 0.5))\n\n\n# Convert sample size to a factor with levels sorted in decreasing order\nsimulation_rct2$sample.size <- factor(\n  simulation_rct2$sample.size, \n  levels = sort(unique(simulation_rct2$sample.size), decreasing = TRUE)\n)\n\n# Convert estimator column to a factor with the specified order\nsimulation_rct2$estimator <- factor(simulation_rct2$estimator, \n                                    levels = desired_order)\n\n# Create the plot for RCT + dependent censoring\nsimulation_graph_rct2 <- simulation_rct2 %>%\n  ggplot(aes(\n    x = estimator, y = estimate,  \n    fill = factor(sample.size, levels = rev(levels(sample.size)))\n  )) +\n  scale_fill_brewer(palette = \"Accent\") +\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +  # Change x-axis label\n  ylab(\"ATE\") +  # Change y-axis label\n  stat_boxplot(geom = \"errorbar\") +\n  geom_hline(\n    yintercept = truth_tau2, linetype = \"dashed\", color = \"red\", \n    alpha = 0.8, size = 0.8\n  ) +\n  theme(\n    legend.title = element_blank(), legend.position = \"bottom\",\n    legend.box = \"vertical\", legend.text = element_text(size = 18),\n    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  \n    # Adjust text angle for better visibility\n    axis.text = element_text(size = 15, face = \"bold\"),\n    axis.title.x = element_text(size = 16, face = \"bold\"),\n    plot.margin = margin(t = 10, r = 10, b = 50, l = 10)  # Add margin\n  ) + \n  coord_cartesian(ylim = c(0, 15))\n```\n\n```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}\n#| label: fig-rct2\n#| fig-cap: \"Estimation results of the ATE for the simulation of a RCT with dependent censoring.\"\n#| warning: false\nsimulation_graph_rct2\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Obs1:  Treatment assignment dependent on X + independent censoring\n# Obs2:  Treatment assignment dependent on X + dependent censoring (conditional \n# on X)\n\n# Function to simulate observational data for two scenarios: Obs1 and Obs2\nsimulate_data_obs <- function(n, \n                              mu = c(1, 1, -1, 1), \n                              sigma = diag(4), \n                              colnames_cov = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n                              tau,\n                              coefT0 = 0.01, \n                              parsS = c(0.5, 0.5, -0.5, 0.5),\n                              parsA = c(-1, -1, -2.5, -1), \n                              parsC_A = c(0), \n                              coefC = 0.03,\n                              parsC = c(0.7, 0.3, -0.25, -0.1), \n                              scenario = \"Obs2\") {\n  \n  # Generate covariates X from a multivariate normal distribution\n  X <- mvrnorm(n, mu, sigma)\n  X <- as.data.frame(X)\n  colnames(X) <- colnames_cov\n  \n  # Propensity score model based on X\n  e <- rowSums(as.matrix(X) %*% diag(parsA))\n  e <- plogis(e)  # Transform to probability scale\n  \n  # Treatment assignment based on the propensity score\n  A <- sapply(e, FUN = function(p) rbinom(n = 1, size = 1, prob = p))\n  \n  # Outcome model based on X\n  X_outcome <- as.matrix(X)\n  epsilon <- runif(n, min = 0.00000001, max = 1)\n  T0 <- -log(epsilon) / (coefT0 * exp(X_outcome %*% parsS))\n  \n  # Define treatment effect (shift in survival time due to treatment)\n  T1 <- T0 + 10\n  \n  if (scenario == \"Obs1\") {\n    # Scenario 1: Independent censoring\n    C <- -log(runif(n, min = 0.00000001, max = 1)) / coefC\n    \n  } else if (scenario == \"Obs2\") {\n    # Scenario 2: Dependent censoring based on X\n    X_censoring <- as.matrix(cbind(X,A))\n    parsC <- c(parsC,parsC_A)\n    \n    C <- -log(runif(n, min = 0.00000001, max = 1)) / \n      (coefC * exp(rowSums(X_censoring %*% diag(parsC))))\n    \n  } else {\n    stop(\"Invalid scenario. Choose 'Obs1' or 'Obs2'.\")\n  }\n  \n  # Determine the true survival time based on treatment\n  T_true <- A * T1 + (1 - A) * T0\n  \n  # Observed time is the minimum of the true survival time and censoring time\n  T_obs <- pmin(T_true, C)\n  \n  # Status indicator: 1 if the event (death) occurred, 0 if censored\n  status <- as.numeric(T_true <= C)\n  \n  # Restricted survival time (censored at tau)\n  T_obs_tau <- pmin(T_obs, tau)\n  status_tau <- as.numeric((T_obs > tau) | (T_obs <= tau & status == 1))\n  \n  # Compile the simulated data into a data frame\n  DATA_target_population <- data.frame(X, tau, A, T0, T1, C, T_obs, T_obs_tau, \n                                       status, status_tau, e)\n  \n  return(DATA_target_population)\n}\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Observational data with no informative censoring\ndata_obs1 <- simulate_data_obs(n = 2000, tau = 25, scenario = \"Obs1\")\n\n# Observational data simulation with dependent censoring\ndata_obs2 <- simulate_data_obs(n = 2000, tau = 25, scenario = \"Obs2\", \n                               coefC = 0.03, parsC = c(0.7,0.3,-0.25,-0.1))\n\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Stratification by treatment \ngroup_0 <- data_obs1 %>%\n  dplyr:: filter(A == 0)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,T_tild=T_obs)\n\ngroup_1 <- data_obs1 %>%\n  dplyr:: filter(A == 1)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,T_tild=T_obs)\n\n# Summary statistics\nsummary_group_0 <- summary(group_0)\nsummary_group_1 <- summary(group_1)\n\nprint(paste(\"Descriptive statistics for group A=0:  \",nrow(group_0)))\nprint(summary_group_0)\n\nprint(paste(\"Descriptive statistics for group A=1:  \",nrow(group_1)))\nprint(summary_group_1)\n\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Stratification by treatment \ngroup_0 <- data_obs2 %>%\n  dplyr:: filter(A == 0)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,status_tau,T_obs,e)\n\ngroup_1 <- data_obs2 %>%\n  dplyr:: filter(A == 1)%>%\n  dplyr:: select(X1,X2,X3,X4,C,T1,T0,status,status_tau,T_obs,e)\n\n# Summary statistics\nsummary_group_0 <- summary(group_0)\nsummary_group_1 <- summary(group_1)\n\nprint(paste(\"Descriptive statistics for group A=0:  \",nrow(group_0)))\nprint(summary_group_0)\n\nprint(paste(\"Descriptive statistics for group A=1:  \",nrow(group_1)))\nprint(summary_group_1)\n\n```\n\n```{r}\n# Simulation for scenario Obs1\ndata_Obs1 <- simulate_data_obs(n = 100000, tau = 25, scenario = \"Obs1\")\n\n#plot_ground_truth(data_Obs1, \n#                  vec_tau, \n#                  tau, \n#                  c(0, 10),\n#                  \"True difference in RMST for Obs #scenario 1\")\n\ntruth_tau3 <-  ground_truth(data_Obs1, tau = 25)\nprint(paste0(\"The ground truth for Obs scenario 1 at time 25 is \", round(truth_tau3, 1)))\n\n# Simulation for scenario Obs2 with specific coefficients and parameters\ndata_Obs2 <- simulate_data_obs(\n  n = 100000, tau = tau, scenario = \"Obs2\", \n  coefC = 0.03, parsC = c(0.7, 0.3, -0.25, -0.1))\n\n#plot_ground_truth(data_Obs2, \n#                  vec_tau, \n#                  tau, \n#                  c(0, 10),\n#                  \"True difference in RMST for Obs #scenario 2\")\n\ntruth_tau4 <- ground_truth(data_Obs2, tau = 25)\nprint(paste0(\"The ground truth for Obs scenario 2 at #time 25 is \", round(truth_tau4, 1)))\n```\n\n```{r, eval=FALSE}\n# Obs1 simulation\nsimulation_obs1 <- compute_estimator(\n  n_sim, tau = tau, scenario = \"Obs1\", \n  X.names.propensity = c(\"X1\", \"X2\", \"X3\", \"X4\"), \n  X.names.outcome = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n  X.names.censoring = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n  nuisance_propensity = c(\"glm\", \"probability forest\"), \n  nuisance_censoring = c(\"cox\", \"survival forest\"), \n  nuisance_survival = c(\"cox\", \"survival forest\"), \n  n.folds_propensity = 5,\n  n.folds_censoring = 5,\n  n.folds_survival = 5,\n  coefC = 0.03\n)\nsave(simulation_obs1, file = \"simulation_obs1.RData\")\n\n\n# Obs2 simulation with specific coefficients and parameters\nsimulation_obs2 <- compute_estimator(\n  n_sim, tau = tau, scenario = \"Obs2\", \n  X.names.propensity = c(\"X1\", \"X2\", \"X3\", \"X4\"), \n  X.names.outcome = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n  X.names.censoring = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n  nuisance_propensity = c(\"glm\", \"probability forest\"), \n  nuisance_censoring = c(\"cox\", \"survival forest\"), \n  nuisance_survival = c(\"cox\", \"survival forest\"), \n  n.folds_propensity = 5,\n  n.folds_censoring = 5,\n  n.folds_survival = 5,\n  coefC = 0.03, \n  parsC = c(0.7, 0.3, -0.25, -0.1)\n)\nsave(simulation_obs2, file = \"simulation_obs2.RData\")\n```\n\n\n```{r}\nload(\"simulations/simulation_obs1.RData\")\nload(\"simulations/simulation_obs2.RData\")\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Update the theme to center the plot title\ntheme_update(plot.title = element_text(hjust = 0.5))\n\n# Convert sample size to a factor with levels sorted in decreasing order\nsimulation_obs1$sample.size <- factor(\n  simulation_obs1$sample.size, \n  levels = sort(unique(simulation_obs1$sample.size), decreasing = TRUE)\n)\n\n# Convert estimator column to a factor with the specified order\nsimulation_obs1$estimator <- factor(simulation_obs1$estimator, \n                                    levels = desired_order)\n\n# Create the plot for Observational + independent censoring\nsimulation_graph_obs1 <- simulation_obs1 %>%\n  ggplot(aes(\n    x = estimator, y = estimate,  \n    fill = factor(sample.size, levels = rev(levels(sample.size)))\n  )) +\n  scale_fill_brewer(palette = \"Accent\") +\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +  # Change x-axis label\n  ylab(\"ATE\") +  # Change y-axis label\n  stat_boxplot(geom = \"errorbar\") +\n  geom_hline(\n    yintercept = truth_tau3, linetype = \"dashed\", color = \"red\", \n    alpha = 0.8, size = 0.8\n  ) +\n  theme(\n    legend.title = element_blank(), legend.position = \"bottom\",\n    legend.box = \"vertical\", legend.text = element_text(size = 18),\n    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  \n    # Adjust text angle for better visibility\n    axis.text = element_text(size = 15, face = \"bold\"),\n    axis.title.x = element_text(size = 16, face = \"bold\"),\n    plot.margin = margin(t = 10, r = 10, b = 50, l = 10)  # Add margin\n  ) + \n  coord_cartesian(ylim = c(0, 15))\n\n```\n\n```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}\n#| label: fig-obs1\n#| fig-cap: \"Estimation results of the ATE for the simulation of an observational study with independent censoring.\"\n#| warning: false\nsimulation_graph_obs1\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Update the theme to center the plot title\ntheme_update(plot.title = element_text(hjust = 0.5))\n\n# Convert sample size to a factor with levels sorted in decreasing order\nsimulation_obs2$sample.size <- factor(\n  simulation_obs2$sample.size, \n  levels = sort(unique(simulation_obs2$sample.size), decreasing = TRUE)\n)\n\n# Convert estimator column to a factor with the specified order\nsimulation_obs2$estimator <- factor(simulation_obs2$estimator, \n                                    levels = desired_order)\n\n# Create the plot for Observational + dependent censoring\nsimulation_graph_obs2 <- simulation_obs2 %>%\n  ggplot(aes(\n    x = estimator, y = estimate,  \n    fill = factor(sample.size, levels = rev(levels(sample.size)))\n  )) +\n  scale_fill_brewer(palette = \"Accent\") +\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +  # Change x-axis label\n  ylab(\"ATE\") +  # Change y-axis label\n  stat_boxplot(geom = \"errorbar\") +\n  geom_hline(\n    yintercept = truth_tau4, linetype = \"dashed\", color = \"red\", \n    alpha = 0.8, size = 0.8\n  ) +\n  theme(\n    legend.title = element_blank(), legend.position = \"bottom\",\n    legend.box = \"vertical\", legend.text = element_text(size = 18),\n    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  \n    # Adjust text angle for better visibility\n    axis.text = element_text(size = 15, face = \"bold\"),\n    axis.title.x = element_text(size = 16, face = \"bold\"),\n    plot.margin = margin(t = 10, r = 10, b = 50, l = 10)  # Add margin\n  ) + \n  coord_cartesian(ylim = c(0, 15))\n\n```\n\n```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}\n#| label: fig-obs2\n#| fig-cap: \"Estimation results of the ATE for the simulation of an observational study with dependent censoring.\"\n#| warning: false\nsimulation_graph_obs2\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# DGP for misspecification \nsimulate_data_mis <- function(n, \n                              mu = c(0.5, 0.5, 0.7, 0.5),\n                              sigma =  matrix(c(1, 0, 0, 0, \n                                                0, 1, 0, 0, \n                                                0, 0, 1, 0,\n                                                0, 0, 0, 1), \n                                              nrow = 4, byrow = TRUE),\n                              colnames_cov = c(\"X1\", \"X2\", \"X3\", \"X4\"),\n                              parsA =  c(0.05, -0.1, 0.5, -0.1),\n                              tau){\n  \n  # Generate X from a multivariate normal distribution\n  X <- MASS::mvrnorm(n, mu, sigma)\n  X <- as.data.frame(X)\n  colnames(X) <- colnames_cov\n  \n  # Treatment variable selection: all X\n  X_treatment <- as.matrix(X)\n  \n  # Propensity score model based on X\n  e <- parsA[1]*X_treatment[, \"X1\"]^2 + parsA[2]*X_treatment[, \"X2\"]^2 + \n    parsA[3]*X_treatment[, \"X3\"]^2 + parsA[4]*X_treatment[, \"X4\"]^2-\n    X_treatment[, \"X1\"]*X_treatment[, \"X2\"] +\n    X_treatment[, \"X1\"]*X_treatment[, \"X4\"]\n  \n  # Logistic regression\n  e <- plogis(e)\n  \n  # Treatment assignment based on the propensity score\n  A <- sapply(e, FUN = function(p) rbinom(n = 1, size = 1, prob = p))\n  \n  # Outcome variable selection: all X\n  X_outcome <- as.matrix(X)\n  \n  lambda <- exp(0.2*X[,1]^2 + 0.3*X[,2]^2 + 0.1*X[,3]^2 + 0.1*X[,4]^2 + \n    X[,1] * X[,2] + X[,3] * X[,4])\n  # Simulate the outcome using the cumulative hazard inversion method\n  epsilon <- runif(n, min = 1e-8, max = 1)\n  T0 <- -log(epsilon) / lambda\n  \n  # Simulate independent censoring time\n  censoring_lambda <- exp(0.05*X[,1]^2 + 0.05*X[,2]^2-0.1*X[,3]^2 + 0.1*X[,4]^2 + \n    X[,3] * X[,1] - X[,2]*X[,4])\n  epsilon <- runif(n, min = 1e-8, max = 1)\n  C <- -log(epsilon) / censoring_lambda\n  \n  \n  # T(1) = T(0) + 1\n  T1 <- T0 + 1\n  \n  # True survival time\n  T_true <- A * T1 + (1 - A) * T0\n  \n  # Observed time\n  T_obs <- pmin(T_true, C)\n  \n  # Status indicator\n  status <- as.numeric(T_true <= C)\n  censor.status <- as.numeric(T_true > C)\n  \n  # Restricted survival time\n  T_obs_tau <- pmin(T_obs, tau)\n  status_tau <- as.numeric((T_obs > tau) | (T_obs <= tau & status == 1))\n  # Compile the simulated data into a data frame\n  DATA_target_population <- data.frame(X, tau, A, T0, T1, C, T_obs, T_obs_tau, \n                                       status, status_tau, censor.status, e)\n  \n  return(DATA_target_population)\n}\n\n\n```\n\n```{r}\n# Function to estimate RMST for each misspecification context\ncompute_estimator_mispec <- function(n_sim, tau, \n                                     X.names.propensity_mis, \n                                     X.names.propensity, \n                                     X.names.outcome,\n                                     X.names.outcome_mis,\n                                     X.names.censoring,\n                                     X.names.censoring_mis,\n                                     nuisance_propensity = \"glm\", \n                                     nuisance_censoring = \"cox\", \n                                     nuisance_survival = \"cox\", \n                                     n.folds_propensity = NULL,\n                                     n.folds_censoring = NULL, \n                                     n.folds_survival = NULL,\n                                     estimator = \"all\",\n                                     sample_sizes = c(8000)) {\n  \n  pb_n <- txtProgressBar(min = 0, max = length(sample_sizes) * n_sim, \n                         style = 3, initial = 0, char = \"#\")\n  on.exit(close(pb_n))\n  \n  # Initialize data frame for each misspecification\n  simulation_mis <- data.frame()\n  simulation_mistreat <- data.frame()\n  simulation_misout <- data.frame()\n  simulation_miscens <- data.frame()\n  simulation_mistreat_out <- data.frame()\n  simulation_miscens_out <- data.frame()\n  simulation_mistreat_cens <- data.frame()\n  simulation_misall <- data.frame()\n\n  # Function to compute estimators for multiple simulations and sample sizes\n  for (n in sample_sizes) {\n    for (i in 1:n_sim) {\n      setTxtProgressBar(pb_n, (which(sample_sizes == n) - 1) * n_sim + i)\n      data <- simulate_data_mis(n, tau = tau)\n\n      # Compute all estimates for the simulated data\n      res_all_mis <- all_estimates(data, n, tau = tau, \n                                   X.names.propensity = X.names.propensity, \n                                   X.names.outcome = X.names.outcome,\n                                   X.names.censoring = X.names.censoring,\n                                   nuisance_propensity = nuisance_propensity, \n                                   nuisance_censoring = nuisance_censoring,\n                                   nuisance_survival = nuisance_survival, \n                                   n.folds_propensity = n.folds_propensity, \n                                   n.folds_censoring = n.folds_censoring, \n                                   n.folds_survival = n.folds_survival,\n                                   estimator)\n      \n      res_all_mistreat <- all_estimates(data, n, tau = tau, \n                                        X.names.propensity = X.names.propensity_mis, \n                                        X.names.outcome = X.names.outcome,\n                                        X.names.censoring = X.names.censoring,\n                                        nuisance_propensity = nuisance_propensity,\n                                        nuisance_censoring = nuisance_censoring,\n                                        nuisance_survival = nuisance_survival,  \n                                        n.folds_propensity = n.folds_propensity, \n                                        n.folds_censoring = n.folds_censoring, \n                                        n.folds_survival = n.folds_survival,\n                                        estimator)\n      \n      res_all_misout <- all_estimates(data, n, tau = tau, \n                                      X.names.propensity = X.names.propensity, \n                                      X.names.outcome = X.names.outcome_mis,\n                                      X.names.censoring = X.names.censoring,\n                                      nuisance_propensity = nuisance_propensity,\n                                      nuisance_censoring = nuisance_censoring,\n                                      nuisance_survival = nuisance_survival,  \n                                      n.folds_propensity = n.folds_propensity, \n                                      n.folds_censoring = n.folds_censoring, \n                                      n.folds_survival = n.folds_survival,\n                                      estimator)\n      \n      res_all_miscens <- all_estimates(data, n, tau = tau, \n                                       X.names.propensity = X.names.propensity, \n                                       X.names.outcome = X.names.outcome,\n                                       X.names.censoring = X.names.censoring_mis,\n                                       nuisance_propensity = nuisance_propensity,\n                                       nuisance_censoring = nuisance_censoring,\n                                       nuisance_survival = nuisance_survival,  \n                                       n.folds_propensity = n.folds_propensity, \n                                       n.folds_censoring = n.folds_censoring, \n                                       n.folds_survival = n.folds_survival,\n                                       estimator)\n      \n      res_all_mistreat_out <- all_estimates(data, n, tau = tau, \n                                            X.names.propensity = X.names.propensity_mis, \n                                            X.names.outcome = X.names.outcome_mis,\n                                            X.names.censoring = X.names.censoring,\n                                            nuisance_propensity = nuisance_propensity,\n                                            nuisance_censoring = nuisance_censoring,\n                                            nuisance_survival = nuisance_survival,\n                                            n.folds_propensity = n.folds_propensity, \n                                            n.folds_censoring = n.folds_censoring, \n                                            n.folds_survival = n.folds_survival,\n                                            estimator)\n      \n      res_all_miscens_out <- all_estimates(data, n, tau = tau, \n                                           X.names.propensity = X.names.propensity, \n                                           X.names.outcome = X.names.outcome_mis,\n                                           X.names.censoring = X.names.censoring_mis,\n                                           nuisance_propensity = nuisance_propensity,\n                                           nuisance_censoring = nuisance_censoring,\n                                           nuisance_survival = nuisance_survival,\n                                           n.folds_propensity = n.folds_propensity, \n                                           n.folds_censoring = n.folds_censoring, \n                                           n.folds_survival = n.folds_survival,\n                                           estimator)\n      \n      res_all_mistreat_cens <- all_estimates(data, n, tau = tau, \n                                             X.names.propensity = X.names.propensity_mis, \n                                             X.names.outcome = X.names.outcome,\n                                             X.names.censoring = X.names.censoring_mis,\n                                             nuisance_propensity = nuisance_propensity,\n                                             nuisance_censoring = nuisance_censoring,\n                                             nuisance_survival = nuisance_survival,\n                                             n.folds_propensity = n.folds_propensity, \n                                             n.folds_censoring = n.folds_censoring, \n                                             n.folds_survival = n.folds_survival,\n                                             estimator)\n      \n      res_all_misall <- all_estimates(data, n, tau = tau, \n                                      X.names.propensity = X.names.propensity_mis, \n                                      X.names.outcome = X.names.outcome_mis,\n                                      X.names.censoring = X.names.censoring_mis,\n                                      nuisance_propensity = nuisance_propensity,\n                                      nuisance_censoring = nuisance_censoring,\n                                      nuisance_survival = nuisance_survival,\n                                      n.folds_propensity = n.folds_propensity, \n                                      n.folds_censoring = n.folds_censoring, \n                                      n.folds_survival = n.folds_survival,\n                                      estimator)\n      \n      # Store the results\n      simulation_mis <- rbind(simulation_mis, res_all_mis)\n      simulation_mistreat <- rbind(simulation_mistreat, res_all_mistreat)\n      simulation_misout <- rbind(simulation_misout, res_all_misout)\n      simulation_miscens <- rbind(simulation_miscens, res_all_miscens)\n      simulation_mistreat_out <- rbind(simulation_mistreat_out, res_all_mistreat_out)\n      simulation_miscens_out <- rbind(simulation_miscens_out, res_all_miscens_out)\n      simulation_mistreat_cens <- rbind(simulation_mistreat_cens, res_all_mistreat_cens)\n      simulation_misall <- rbind(simulation_misall, res_all_misall)\n    }\n  }\n  \n  # Fusion of dataframe\n  return(list(\n    simulation_mis = simulation_mis,\n    simulation_mistreat = simulation_mistreat,\n    simulation_misout = simulation_misout,\n    simulation_miscens = simulation_miscens,\n    simulation_mistreat_out = simulation_mistreat_out,\n    simulation_miscens_out = simulation_miscens_out,\n    simulation_mistreat_cens = simulation_mistreat_cens,\n    simulation_misall = simulation_misall\n  ))\n}\n```\n\n\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nmis <- simulate_data_mis(n=2000,tau=0.5)\nsummary(mis)\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Stratification by treatment \ngroup_0 <- mis %>%\n  dplyr:: filter(A == 0)%>%\n  dplyr:: select(X1,X2,X3,C,T1,T0,status,T_obs,status_tau,e)\n\ngroup_1 <- mis %>%\n  dplyr:: filter(A == 1)%>%\n  dplyr:: select(X1,X2,X3,C,T1,T0,status,T_obs,status_tau,e)\n\n# Summary statistics\nsummary_group_0 <- summary(group_0)\nsummary_group_1 <- summary(group_1)\n\nprint(paste(\"Descriptive statistics for group A=0:  \",nrow(group_0)))\nprint(summary_group_0)\n\nprint(paste(\"Descriptive statistics for group A=1:  \",nrow(group_1)))\nprint(summary_group_1)\n\n```\n\n```{r}\n# Mis scenario \ntau_mis <- 0.5\nvec_tau_complex <- seq(0, 10, by = 0.05)\ndata_mis <- simulate_data_mis(n = 150000, tau = tau_mis)\n\n#plot_ground_truth(data_mis,\n#                  vec_tau_complex, \n#                  tau_mis, \n#                  c(0, 1), \n#                  \"True difference in RMST for Mis scenario\")\n\ntruth_complex_mis <- ground_truth(data_mis, tau = tau_mis)\n\nprint(paste0(\"The ground truth for mis scenario at time 0.45 is \", round(truth_complex_mis,2)))\n```\n\n\n```{r eval=FALSE}\nn_sim <- 100\ntau <- 0.5\nsimulation_mis <- compute_estimator(\n  n_sim, tau = tau, scenario = \"Mis\", \n  X.names.propensity = c(\"I(X1^2)\", \"I(X2^2)\",\"I(X3^2)\", \"I(X4^2)\", \n                         \"X1*X2\",\"X1*X4\"),\n  X.names.outcome = c(\"I(X1^2)\", \"I(X2^2)\",\"I(X3^2)\", \"I(X4^2)\", \n                      \"X1:X2\", \"X3:X4\"),\n  X.names.censoring = c(\"I(X1^2)\", \"I(X2^2)\",\"I(X3^2)\", \"I(X4^2)\", \n                        \"X1:X3\", \"X2:X4\"),\n  nuisance_propensity = c(\"glm\"), \n  nuisance_censoring = c(\"cox\"), \n  nuisance_survival = c(\"cox\"), \n  n.folds_propensity = NULL,\n  n.folds_censoring = NULL,\n  n.folds_survival = NULL,\n  sample_sizes = c(500, 1000, 2000, 4000, 8000),\n  estimator = c(\"Naive\", \"KM\", \"IPTW KM\", \"IPCW KM\", \"BJ\", \n                \"IPTW-IPCW KM\", \"IPTW-BJ\", \"G_formula (T-learners)\", \n                \"G_formula (S-learner)\", \"AIPTW-AIPCW\")\n)\nsave(simulation_mis, file=\"simulation_mis.RData\") \n\nsimulation_mis_c <- compute_estimator(\n  n_sim, tau = tau, scenario = \"Mis\", \n  X.names.propensity = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n  X.names.outcome = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n  X.names.censoring = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n  nuisance_propensity = c(\"probability forest\"), \n  nuisance_censoring = c(\"survival forest\"), \n  nuisance_survival = c(\"survival forest\"), \n  n.folds_propensity = 5,\n  n.folds_censoring = 5,\n  n.folds_survival = 5,\n  sample_sizes = c(500, 1000, 2000, 4000, 8000),\n  estimator = c(\"IPTW KM\", \"IPCW KM\", \"BJ\", \n                \"IPTW-IPCW KM\", \"IPTW-BJ\", \"G_formula (T-learners)\", \n                \"G_formula (S-learner)\", \"AIPTW-AIPCW\",\n                \"grf - Causal Survival Forest\")\n)\n\nsave(simulation_mis_c, file=\"simulation_mis_c.RData\") \n\nsimulation_mis_c_16000 <- compute_estimator(\n  n_sim, tau = tau, scenario = \"Mis\", \n  X.names.propensity = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n  X.names.outcome = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n  X.names.censoring = c(\"X1\",\"X2\",\"X3\",\"X4\"),\n  nuisance_propensity = c(\"probability forest\"), \n  nuisance_censoring = c(\"survival forest\"), \n  nuisance_survival = c(\"survival forest\"), \n  n.folds_propensity = 5,\n  n.folds_censoring = 5,\n  n.folds_survival = 5,\n  sample_sizes = 16000,\n  estimator = c(\"IPTW KM\", \"G_formula (T-learners)\")\n)\nsave(simulation_mis_c_16000, file=\"simulation_mis_c_16000.RData\")  \n```\n\n\n```{r}\nload(\"simulations/simulation_mis.RData\")\nload(\"simulations/simulation_mis_c.RData\")\nload(\"simulations/simulation_mis_c_16000.RData\")\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n# Define the desired order of the estimators\nsimulation_mis2 <- rbind(simulation_mis,simulation_mis_c)\nsimulation_mis2 <- rbind(simulation_mis2,simulation_mis_c_16000)\n\ndesired_order <- c(\n  \"Naive\",\n  \"KM\",\n  \"SurvRM2 - KM\",\n  \"IPTW KM (Log. Reg.)\",\n  \"IPCW KM (Cox)\",\n  \"BJ (Cox)\",\n  \"IPTW-BJ (Cox & Log. Reg.)\",\n  \"IPTW-IPCW KM (Cox & Log. Reg.)\",\n  \"G-formula (Cox/ T-learners)\",\n  \"G-formula (Cox/ S-learner)\",\n  \"AIPTW-AIPCW (Cox & Cox & Log. Reg.)\",\n  \"grf - Causal Survival Forest\",\n  \"IPTW KM (Forest)\",\n  \"IPCW KM (Forest)\",\n  \"BJ (Forest)\",\n  \"IPTW-BJ (Forest)\",\n  \"IPTW-IPCW KM (Forest)\",\n  \"G-formula (Forest/ T-learners)\",\n  \"G-formula (Forest/ S-learner)\",\n  \"AIPTW-AIPCW (Forest)\")\n\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_mis2$sample.size <- factor(simulation_mis2$sample.size, \n                                      levels = sort(unique(simulation_mis2$sample.size), \n                                                    decreasing = TRUE))\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_mis2$estimator <- factor(simulation_mis2$estimator, levels = desired_order)\n\nsimulation_graph_mis <- simulation_mis2 %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, \n                                                         levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"No misspecification:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +  # Changer le label de l'axe x\n  ylab(\"ATE\") +  # Retirer le label de l'axe y\n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Changer geom_hline en geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(size = 15, angle = 45, vjust = 1, hjust = 1),\n          axis.text.y = element_text(size = 15),\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n\n```{r fig.width=15, fig.height=10, message=FALSE, warning=FALSE}\n#| label: fig-mis3\n#| fig-cap: \"Estimation results of the ATE for the simulation of an observational study with dependent censoring and non linear relationships.\"\n#| warning: false\nsimulation_graph_mis\n```\n\n\n```{r eval=FALSE}\nn_sim <- 100\ntau <- 0.5\nmis <- compute_estimator_mispec(n_sim, tau = tau, \n                                   X.names.propensity = c(\"I(X1^2)\", \"I(X2^2)\",\n                                                          \"I(X3^2)\", \"I(X4^2)\", \n                                                          \"X1*X2\",\"X1*X4\"),\n                                   X.names.outcome = c(\"I(X1^2)\", \"I(X2^2)\",\n                                                       \"I(X3^2)\", \"I(X4^2)\", \n                                                       \"X1:X2\", \"X3:X4\"),\n                                   X.names.censoring = c(\"I(X1^2)\", \"I(X2^2)\",\n                                                         \"I(X3^2)\", \"I(X4^2)\", \n                                                         \"X1:X3\", \"X2:X4\"),\n                                   X.names.propensity_mis = c(\"I(X1^2)\",\"I(X2^2)\",\n                                                              \"I(X3^2)\", \"I(X4^2)\"),\n                                   X.names.outcome_mis = c(\"I(X1^2)\", \"I(X2^2)\",\n                                                           \"I(X3^2)\", \"I(X4^2)\"),\n                                   X.names.censoring_mis = c(\"I(X1^2)\", \"I(X2^2)\",\n                                                             \"I(X3^2)\", \"I(X4^2)\"),\n                                   nuisance_propensity = c(\"glm\"), \n                                   nuisance_censoring = c(\"cox\"), \n                                   nuisance_survival = c(\"cox\"),\n                                   estimator = estimators,\n                                   sample_size = 8000)\n\n\n# Initialize a list to decompose the results\nmerged_results <- list()\n\n# All the defined sceanario\nscenarios <- c(\"simulation_mis\", \"simulation_mistreat\", \"simulation_misout\",\n               \"simulation_miscens\", \"simulation_mistreat_out\", \n               \"simulation_miscens_out\", \"simulation_mistreat_cens\", \n               \"simulation_misall\")\n\n# Loop through all scenarios\nfor (s in scenarios) {\n  # Initialize an empty dataframe\n  scenario_results <- data.frame()\n  \n  # Loop through all sample sizes\n  for (i in seq_along(sample_sizes)) {\n    # Append the results for the given scenario and sample size \n    scenario_results <- rbind(scenario_results, results[[i]][[s]])\n  }\n  \n  # Add the results for the given scenario to the results list \n  merged_results[[s]] <- scenario_results\n  \n  # Save the final results for the given scenario in an .RData file\n  assign(paste0(s), scenario_results)\n  save(list = paste0(s), file = sprintf(\"%s.RData\", s))\n}\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\nload(\"simulations/simulation_mis2.RData\")\nload(\"simulations/simulation_mistreat.RData\")\nload(\"simulations/simulation_miscens.RData\")\nload(\"simulations/simulation_misout.RData\")\n\n# Define the desired order of the estimators\ndesired_order_mis <- c(\n  \"Naive\", \"KM\",\n\"IPTW KM (Log. Reg.)\",\n  \"IPCW KM (Cox)\", \"BJ (Cox)\",  \"IPTW-BJ (Cox & Log. Reg.)\", \n\"IPTW-IPCW KM (Cox & Log. Reg.)\",\n  \"G-formula (Cox/ T-learners)\", \"G-formula (Cox/ S-learner)\",\n  \"AIPTW-AIPCW (Cox & Cox & Log. Reg.)\"\n)\n\nsimulation_mis2 <- simulation_mis2[simulation_mis2$estimator %in% desired_order_mis, ]\n\n\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_mis2$sample.size <- factor(simulation_mis2$sample.size, \n                                      levels = sort(unique(simulation_mis2$sample.size), \n                                                    decreasing = TRUE))\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_mis2$estimator <- factor(simulation_mis2$estimator, levels = desired_order)\n\nsimulation_graph_mis2 <- simulation_mis2 %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, \n                                                         levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"No misspecification:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +\n  ylab(\"ATE\") + \n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Change geom_hline to geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_mistreat$sample.size <- factor(simulation_mistreat$sample.size, levels = sort(unique(simulation_mistreat$sample.size), decreasing = TRUE))\n\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_mistreat$estimator <- factor(simulation_mistreat$estimator, levels = desired_order_mis)\n\nsimulation_graph_mis_mistreat <- simulation_mistreat %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"Misspecification of treatment model:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +  \n  ylab(\"ATE\") + \n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Changer geom_hline en geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_miscens$sample.size <- factor(simulation_miscens$sample.size, levels = sort(unique(simulation_miscens$sample.size), decreasing = TRUE))\n\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_miscens$estimator <- factor(simulation_miscens$estimator, levels = desired_order_mis)\n\nsimulation_graph_mis_miscens <- simulation_miscens %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"Misspecification of censoring model:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +\n  ylab(\"ATE\") +\n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Change geom_hline to geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_misout$sample.size <- factor(simulation_misout$sample.size, levels = sort(unique(simulation_misout$sample.size), decreasing = TRUE))\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_misout$estimator <- factor(simulation_misout$estimator, levels = desired_order_mis)\n\nsimulation_graph_mis_misout <- simulation_misout %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"Misspecification of outcome model:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") + \n  ylab(\"ATE\") + \n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Changer geom_hline to geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n\n```{r fig.width=25, fig.height=25, message=FALSE, warning=FALSE}\n#| label: fig-mis\n#| fig-cap: \"Estimation results of the ATE for an observational study with dependent censoring in case of a single misspecification.\"\n#| warning: false\ngrid.arrange(simulation_graph_mis2, simulation_graph_mis_miscens, simulation_graph_mis_misout, simulation_graph_mis_mistreat, ncol = 2, nrow = 2)\n```\n\n```{r}\nload(\"simulations/simulation_mistreat_out.RData\")\nload(\"simulations/simulation_miscens_out.RData\")\nload(\"simulations/simulation_mistreat_cens.RData\")\nload(\"simulations/simulation_misall.RData\")\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_mistreat_out$sample.size <- factor(simulation_mistreat_out$sample.size, levels = sort(unique(simulation_mistreat_out$sample.size), decreasing = TRUE))\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_mistreat_out$estimator <- factor(simulation_mistreat_out$estimator, levels = desired_order_mis)\n\nsimulation_graph_mis_mistreat_out <- simulation_mistreat_out %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"Misspecification of outcome and treatment model:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") + \n  ylab(\"ATE\") +\n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Change geom_hline to geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_miscens_out$sample.size <- factor(simulation_miscens_out$sample.size, levels = sort(unique(simulation_miscens_out$sample.size), decreasing = TRUE))\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_miscens_out$estimator <- factor(simulation_miscens_out$estimator, levels = desired_order_mis)\n#simulation_mis$estimator[is.na(simulation_mis$estimator)] <- \"G_formula (S-learner)\"\n\nsimulation_graph_mis_miscens_out <- simulation_miscens_out %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"Misspecification of censoring and outcome model:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") +  \n  ylab(\"ATE\") + \n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Change geom_hline to geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\n\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_mistreat_cens$sample.size <- factor(simulation_mistreat_cens$sample.size, levels = sort(unique(simulation_mistreat_cens$sample.size), decreasing = TRUE))\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_mistreat_cens$estimator <- factor(simulation_mistreat_cens$estimator, levels = desired_order_mis)\n#simulation_mis$estimator[is.na(simulation_mis$estimator)] <- \"G_formula (S-learner)\"\n\nsimulation_graph_mis_mistreat_cens <- simulation_mistreat_cens %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"Misspecification of censoring and treatment model:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") + \n  ylab(\"ATE\") + \n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Change geom_hline to geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n```{r echo=FALSE, message=FALSE, warning=FALSE}\ntheme_update(plot.title = element_text(hjust = 0.5))\n\nsimulation_misall$sample.size <- factor(simulation_misall$sample.size, levels = sort(unique(simulation_misall$sample.size), decreasing = TRUE))\n\n\n# Convert 'estimator' column to a factor with the specified order\nsimulation_misall$estimator <- factor(simulation_misall$estimator, levels = desired_order_mis)\n#simulation_mis$estimator[is.na(simulation_mis$estimator)] <- \"G_formula (S-learner)\"\n\nsimulation_graph_mis_all <- simulation_misall %>%\n  ggplot(aes(x = estimator, y = estimate,  fill = factor(sample.size, levels = rev(levels(sample.size))))) +\n  scale_fill_brewer(palette = \"Accent\") +\n  ggtitle(\"Misspecification of all models:  \")+\n  geom_boxplot(alpha = 0.9, show.legend = TRUE, position = \"dodge\") +\n  xlab(\"\") + \n  ylab(\"ATE\") + \n  stat_boxplot(geom=\"errorbar\")+\n  geom_hline(yintercept = truth_complex_mis , linetype = \"dashed\", color = \"red\", alpha = 0.8,\n             size = 0.8) +  # Change geom_hline to geom_vline\n  theme(legend.title = element_blank(), legend.position = \"bottom\",\n          legend.box = \"vertical\", legend.text = element_text(size=18),\n          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),  # Adjust text angle for better visibility\n          axis.text = element_text(size=20, face = \"bold\"),\n          plot.title = element_text(size=24, face = \"bold\"),\n          axis.title.x = element_text(size=20, face = \"bold\"))+\n            coord_cartesian(ylim = c(0.1,0.4))\n\n```\n\n```{r fig.width=25, fig.height=25, message=FALSE, warning=FALSE}\n#| label: fig-mis2\n#| fig-cap: \"Estimation results of the ATE for an observational study with dependent censoring in case of a two or more misspecifications.\"\n#| warning: false\ngrid.arrange(simulation_graph_mis_mistreat_out, simulation_graph_mis_miscens_out, simulation_graph_mis_mistreat_cens, simulation_graph_mis_all, ncol = 2, nrow = 2)\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":{"pdf":{"pdf-engine":"lualatex"}},"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","self-contained":true,"output-file":"Notebook_causal_survival.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","title":"Causal survival analysis","subtitle":"Treatment Effect Estimation in Causal Survival Analysis: Practical Recommendations","author":[{"name":"Charlotte Voinot","corresponding":true,"email":"charlotte.voinot@sanofi.com","url":"https://chvoinot.github.io/","affiliations":[{"name":"Sanofi R&D","department":"CMEI","url":"https://www.sanofi.fr/fr/"},{"name":"INRIA","department":"Premedical","url":"https://www.inria.fr/fr/premedical"},{"name":"INSERM","url":"https://www.inserm.fr/"},{"name":"Université de Montpellier","url":"https://www.umontpellier.fr/"}]},{"name":"Clément Berenfeld","corresponding":true,"email":"clement.berenfeld@uni-potsdam.de","url":"https://cberenfeld.github.io","affiliations":[{"name":"Universität Potsdam, Potsdam, Germany","departement":"Institut für Mathematik","url":"https://www.uni-potsdam.de/en/university-of-potsdam"}]},{"name":"Imke Mayer","corresponding":true,"email":"imke.mayer@owkin.com, now affiliated with Owkin","affiliations":[{"name":"Charité -- Universität Berlin, Berlin, Germany","departement":"Institut für Public Health","url":"https://www.charite.de/"}]},{"name":"Bernard Sebastien","corresponding":true,"email":"bernard.sebastien@sanofi.com","affiliations":[{"name":"Sanofi R&D","department":"CMEI","url":"https://www.sanofi.fr/fr/"}]},{"name":"Julie Josse","corresponding":true,"email":"julie.josse@inria.fr","url":"https://juliejosse.com/","affiliations":[{"name":"INRIA","department":"Premedical","url":"https://www.inria.fr/fr/premedical"},{"name":"INSERM","url":"https://www.inserm.fr/"},{"name":"Université de Montpellier","url":"https://www.umontpellier.fr/"}]}],"date":"last-modified","date-modified":"last-modified","github-user":"chvoinot","repo":"Simple_simulation_causal_survival","editor":{"markdown":{"wrap":7}}},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":{"pdf":{"pdf-engine":"lualatex"}},"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"Notebook_causal_survival.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"title":"Causal survival analysis","subtitle":"Treatment Effect Estimation in Causal Survival Analysis: Practical Recommendations","author":[{"name":"Charlotte Voinot","corresponding":true,"email":"charlotte.voinot@sanofi.com","url":"https://chvoinot.github.io/","affiliations":[{"name":"Sanofi R&D","department":"CMEI","url":"https://www.sanofi.fr/fr/"},{"name":"INRIA","department":"Premedical","url":"https://www.inria.fr/fr/premedical"},{"name":"INSERM","url":"https://www.inserm.fr/"},{"name":"Université de Montpellier","url":"https://www.umontpellier.fr/"}]},{"name":"Clément Berenfeld","corresponding":true,"email":"clement.berenfeld@uni-potsdam.de","url":"https://cberenfeld.github.io","affiliations":[{"name":"Universität Potsdam, Potsdam, Germany","departement":"Institut für Mathematik","url":"https://www.uni-potsdam.de/en/university-of-potsdam"}]},{"name":"Imke Mayer","corresponding":true,"email":"imke.mayer@owkin.com, now affiliated with Owkin","affiliations":[{"name":"Charité -- Universität Berlin, Berlin, Germany","departement":"Institut für Public Health","url":"https://www.charite.de/"}]},{"name":"Bernard Sebastien","corresponding":true,"email":"bernard.sebastien@sanofi.com","affiliations":[{"name":"Sanofi R&D","department":"CMEI","url":"https://www.sanofi.fr/fr/"}]},{"name":"Julie Josse","corresponding":true,"email":"julie.josse@inria.fr","url":"https://juliejosse.com/","affiliations":[{"name":"INRIA","department":"Premedical","url":"https://www.inria.fr/fr/premedical"},{"name":"INSERM","url":"https://www.inserm.fr/"},{"name":"Université de Montpellier","url":"https://www.umontpellier.fr/"}]}],"date":"last-modified","date-modified":"last-modified","github-user":"chvoinot","repo":"Simple_simulation_causal_survival","editor":{"markdown":{"wrap":7}}},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":[]}